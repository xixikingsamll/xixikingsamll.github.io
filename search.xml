<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Next.js笔记（二）</title>
      <link href="/2024/10/10/Next-js%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/10/10/Next-js%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>本期 Next.js 笔记（二）用于记录我自己的学习过程，本期包括以下内容</p><ul><li>介绍 Next.js 的路由系统</li><li><p>介绍页面文件中各个小文件的职能</p></li><li><p>对路由的一些处理手段（包括国际化）</p></li></ul><h1 id="2-Next-js-的路由系统"><a href="#2-Next-js-的路由系统" class="headerlink" title="2. Next.js 的路由系统"></a>2. Next.js 的路由系统</h1><p>​ 在笔记（一）中其实就已经提到过了，Next.js 的路由主要是以文件系统为主导的，有 App Router 和 Page Router 两种，在 Next.js 13 版本往后所加入的 App Router 在合理性和可管理性上要比 Page Router 要更加优秀，在前面的笔记就已经详细对比过了，所以以后的项目还是采用 App Router 这个路由系统（毕竟我公司也是用的这种，习惯了……），接下来的大部分内容都采用的 App Router 的写法和案例。</p><h2 id="2-1-路由基础知识"><a href="#2-1-路由基础知识" class="headerlink" title="2.1 路由基础知识"></a>2.1 路由基础知识</h2><p>​ 提到了文件系统，那就不得不提一下树形结构了，文件系统中各个文件夹和子文件都有它的根和树叶，整体结构是非常清晰明了的，Next.js 的路由正式和其同样的思想，就比如 page 目录下的 index.js 就是根目录<code>/</code>,page 目录下的文件夹 about 就是路由<code>/about</code>，以此类推。</p><ul><li>路由的文件约定：Next.js 提供了一组特殊文件来在嵌套路由中创建具有特定行为的 UI</li></ul><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><a href="https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#layouts"><code>layout</code></a></td><td>布局 UI（可以放一些<Header>,<Footer>组件什么的 ）</td></tr><tr><td><a href="https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#pages"><code>page</code></a></td><td>页面 UI（主要入口文件，如果没有这个文件这个路径不能够被公开访问）</td></tr><tr><td><a href="https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming"><code>loading</code></a></td><td>loading UI</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/file-conventions/not-found"><code>not-found</code></a></td><td>未找到段及其子项的 UI（404 Not Found）</td></tr><tr><td><a href="https://nextjs.org/docs/app/building-your-application/routing/error-handling"><code>error</code></a></td><td>段及其子段的错误 UI</td></tr><tr><td><a href="https://nextjs.org/docs/app/building-your-application/routing/error-handling"><code>global-error</code></a></td><td>全局错误用户界面</td></tr><tr><td><a href="https://nextjs.org/docs/app/building-your-application/routing/route-handlers"><code>route</code></a></td><td>服务器端 API 端点</td></tr><tr><td><a href="https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts#templates"><code>template</code></a></td><td>专门重新渲染的布局 UI（一般也用不到，其实只要用前两个也就够了）</td></tr><tr><td><a href="https://nextjs.org/docs/app/api-reference/file-conventions/default"><code>default</code></a></td><td><a href="https://nextjs.org/docs/app/building-your-application/routing/parallel-routes">并行路线</a>的后备 UI（可以用来重定向到主页什么的）</td></tr></tbody></table></div><p>​ 他们一般都是按照特定的顺序进行渲染的</p><ul><li><p><code>layout.js</code></p></li><li><p><code>template.js</code></p></li><li><p><code>error.js</code>（React 错误边界）</p></li><li><p><code>loading.js</code>（React Suspense 边界）</p></li><li><p><code>not-found.js</code>（React 错误边界）</p></li><li><p><code>page.js</code>或嵌套<code>layout.js</code></p></li></ul><h2 id="2-2-嵌套路由"><a href="#2-2-嵌套路由" class="headerlink" title="2.2 嵌套路由"></a>2.2 嵌套路由</h2><p>​ 嵌套路由其实就是每个页面文件的子组件，当使用 <code>App Router</code> 定义嵌套路由时，每个页面或子页面都会渲染到相应布局中的 <code>children</code> 部分。简单来说，<code>children</code> prop 的作用是告诉布局组件在页面结构中应该显示哪些子页面内容。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// layout.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">DashboardLayout</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  children,</span></span><br><span class="line"><span class="params">&#125;: &#123;</span></span><br><span class="line"><span class="params">  children: React.ReactNode;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// children代表的就是子组件</span></span><br></pre></td></tr></table></figure><h2 id="2-3-连接和导航"><a href="#2-3-连接和导航" class="headerlink" title="2.3 连接和导航"></a>2.3 连接和导航</h2><p>Next.js 中有四种方式可以在路由之间导航（本次笔记仅介绍前面两种）：</p><ul><li><code>&lt;Link&gt;</code>组件</li><li><code>useRouter</code>钩子（客户端组件）</li><li><code>redirect</code>函数（服务端组件）</li><li>原始浏览器历史记录 api</li></ul><p>首先是第一种最常用的，详细的 API 这里就不提供了，请官网<a href="https://nextjs.org/docs/app/api-reference/components/link">参阅 API 参考</a>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Link</span> <span class="keyword">from</span> <span class="string">&quot;next/link&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/dashboard&quot;</span>&gt;</span>Dashboard<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有一种非常常用的写法，通常用来渲染列表数据</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Link</span> <span class="keyword">from</span> <span class="string">&quot;next/link&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用到了循环渲染</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">PostList</span>(<span class="params">&#123; posts &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;posts.map((post) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;post.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;</span>`/<span class="attr">blog</span>/$&#123;<span class="attr">post.slug</span>&#125;`&#125;&gt;</span>&#123;post.title&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://nextjs.org/docs/app/api-reference/functions/use-pathname"><code>usePathname()</code></a>可以用来获取当前路由的名称：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;use client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; usePathname &#125; <span class="keyword">from</span> <span class="string">&quot;next/navigation&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Link</span> <span class="keyword">from</span> <span class="string">&quot;next/link&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Links</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> pathname = <span class="title function_">usePathname</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Link</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">link</span> $&#123;<span class="attr">pathname</span> === <span class="string">&quot;/&quot;</span> ? &quot;<span class="attr">active</span>&quot; <span class="attr">:</span> &quot;&quot;&#125;`&#125; <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            Home</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">link</span> $&#123;<span class="attr">pathname</span> === <span class="string">&quot;/about&quot;</span> ? &quot;<span class="attr">active</span>&quot; <span class="attr">:</span> &quot;&quot;&#125;`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &gt;</span></span></span><br><span class="line"><span class="language-xml">            About</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是第二种<code>useRouter</code>钩子（这个的用法和 vue 中的<code>useRouter</code>钩子的用法非常类似）：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;use client&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&quot;next/navigation&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> router.push(&quot;/dashboard&quot;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      Dashboard</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-动态路由路线"><a href="#2-4-动态路由路线" class="headerlink" title="2.4 动态路由路线"></a>2.4 动态路由路线</h2><p>在命名文件夹的时候将名字用中括号包裹，例如<code>app/blog/[slug]/page.js</code>，那么其中的 slug 其实就作为了 prop 参数来传递给子文件中的所有页面文件，这就是 Next.js 中的文件路由系统的动态段。</p><p>不仅如此，动态路由还适用于多级的动态适配：</p><div class="table-container"><table><thead><tr><th>路线</th><th>示例 URL</th><th><code>params</code></th></tr></thead><tbody><tr><td><code>app/shop/[...slug]/page.js</code></td><td><code>/shop/a</code></td><td><code>&#123; slug: [&#39;a&#39;] &#125;</code></td></tr><tr><td><code>app/shop/[...slug]/page.js</code></td><td><code>/shop/a/b</code></td><td><code>&#123; slug: [&#39;a&#39;, &#39;b&#39;] &#125;</code></td></tr><tr><td><code>app/shop/[...slug]/page.js</code></td><td><code>/shop/a/b/c</code></td><td><code>&#123; slug: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] &#125;</code></td></tr></tbody></table></div><h2 id="2-5-平行路由路线"><a href="#2-5-平行路由路线" class="headerlink" title="2.5 平行路由路线"></a>2.5 平行路由路线</h2><p>在一个页面我们可以由多个组件构成，但是其实在路由系统中，一个页面也是可以由多个子页面文件作为组件来构成，其原理是一样的</p><p><strong>并行路由使用命名插槽</strong>创建。插槽按照惯例定义<code>@folder</code>。例如，以下文件结构定义了两个插槽：<code>@analytics</code>和<code>@team</code>，插槽作为 props 传递给共享父布局。对于上面的示例，中的组件<code>app/layout.js</code>现在接受<code>@analytics</code>和<code>@team</code>插槽 props，并且可以与 prop 并行渲染它们<code>children</code>，那么我们在使用的时候就得：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Layout</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  children,</span></span><br><span class="line"><span class="params">  team,</span></span><br><span class="line"><span class="params">  analytics,</span></span><br><span class="line"><span class="params">&#125;: &#123;</span></span><br><span class="line"><span class="params">  children: React.ReactNode;</span></span><br><span class="line"><span class="params">  analytics: React.ReactNode;</span></span><br><span class="line"><span class="params">  team: React.ReactNode;</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;team&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;analytics&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info simple"><p>提醒 prop<code>children</code>是一个隐式插槽，不需要映射到文件夹。这意味着<code>app/page.js</code>相当于<code>app/@children/page.js</code>。</p></div><h2 id="2-6-路由中间件"><a href="#2-6-路由中间件" class="headerlink" title="2.6 路由中间件"></a>2.6 路由中间件</h2><p>中间件能够在请求完成之前运行代码，比较常用的场景就是重定向和身份验证，所有路由加载的时候默认是要执行中间件代码的，在我实习的时候中间件的作用非常大，在处理国际化和动态路由的时候非常有用。</p><p><code>middleware.ts</code>（不一定所有代码都要放在这个文件里面，这个只是中间件的主要文件，也就是主要配置文件，我们可以适当配置一些 hook 来丰富其内容，简化其结构）</p><p>由于项目中的所有路由都会调用中间件代码，自然也可以用一些排除手段来排除其对某些特殊路由的影响：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用matcher来排除你想要排除的路径</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">matcher</span>: [<span class="string">&quot;/about/:path*&quot;</span>, <span class="string">&quot;/dashboard/:path*&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-关于中间件的一些补充（国际化）"><a href="#3-关于中间件的一些补充（国际化）" class="headerlink" title="3. 关于中间件的一些补充（国际化）"></a>3. 关于中间件的一些补充（国际化）</h1><p>所谓的国际化，Next.js 能够根据用户的浏览器语言、IP 地址、或者查询参数，自动为用户选择适当的语言环境并加载相应的本地化内容。</p><p>那么如何通过中间件来实现国际化呢？</p><ul><li>首先我们要从请求头中的<code>Accept-Language</code> 中读取到用户的语言偏好</li><li>然后重定向到特定语言的路由</li><li>我们还可以根据当前的语言类型加载对应的 json 资源或者别的能够区分语言的内容</li></ul><p>就比如下面的代码就实现了重定向：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/middleware.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NextResponse</span> &#125; <span class="keyword">from</span> <span class="string">&quot;next/server&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">middleware</span>(<span class="params">req</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取请求头中的 `Accept-Language` 以确定用户语言</span></span><br><span class="line">  <span class="keyword">const</span> &#123; nextUrl &#125; = req;</span><br><span class="line">  <span class="keyword">const</span> acceptLanguage = req.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;accept-language&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> language = acceptLanguage ? acceptLanguage.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>] : <span class="string">&quot;en&quot;</span>; <span class="comment">// 默认使用 &#x27;en&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建新的 URL，根据用户语言重定向</span></span><br><span class="line">  <span class="keyword">const</span> url = nextUrl.<span class="title function_">clone</span>();</span><br><span class="line">  <span class="keyword">if</span> (language === <span class="string">&quot;fr&quot;</span>) &#123;</span><br><span class="line">    url.<span class="property">pathname</span> = <span class="string">`/fr<span class="subst">$&#123;nextUrl.pathname&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (language === <span class="string">&quot;es&quot;</span>) &#123;</span><br><span class="line">    url.<span class="property">pathname</span> = <span class="string">`/es<span class="subst">$&#123;nextUrl.pathname&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    url.<span class="property">pathname</span> = <span class="string">`/en<span class="subst">$&#123;nextUrl.pathname&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回新的请求响应，重定向用户到相应语言的页面</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">NextResponse</span>.<span class="title function_">redirect</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">matcher</span>: <span class="string">&quot;/:path*&quot;</span>, <span class="comment">// 应用中间件到所有路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Next.js 还允许你通过 <code>next.config.js</code> 来配置国际化。你可以为项目指定多个支持的语言和默认语言：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">i18n</span>: &#123;</span><br><span class="line">    <span class="attr">locales</span>: [<span class="string">&quot;en&quot;</span>, <span class="string">&quot;fr&quot;</span>, <span class="string">&quot;es&quot;</span>], <span class="comment">// 支持的语言</span></span><br><span class="line">    <span class="attr">defaultLocale</span>: <span class="string">&quot;en&quot;</span>, <span class="comment">// 默认语言</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦用户被重定向到带有语言前缀的路由，可以通过动态加载相应的翻译内容。例如，可以使用 <code>next-translate</code> 或 <code>react-intl</code> 等库来管理多语言内容的翻译</p><p>最后总结一下可能要用到的资源</p><ul><li>next-intl</li><li>next-international</li><li>next-translate</li><li>next-i18n-router</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Next.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next.js笔记（一）</title>
      <link href="/2024/10/09/Next-js%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/10/09/Next-js%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>本期 Next.js 笔记（一）用于记录我自己的学习过程，本期包括以下内容：</p><ul><li>我本人对于 Next.js 的认识</li><li>Next.js 与其他框架的区别</li><li>脚手架搭建 Next.js 项目</li></ul><h1 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h1><p>​ Next.js 是一个基于 react 框架来服务于全栈搭建 web 应用的一个工具，如果您尚未持有对于 react 的学习经历和开发经历，那么我觉得想要开始学习 Next.js 是比较困难的，但是也不排除您是一位着急进入开发的一根绳子上的程序员。（就像我一样实习的时候 react 都不会就开始写 Next.js 了，组长告诉我没关系的，两个一起学就完事了 😂） Next.js 由 vercel 开发，它不仅提供了 React 的核心特性，还增强了以下几方面的能力：</p><ul><li><strong>服务端渲染（SSR）</strong>：支持在服务端预先渲染页面，从而提升页面的加载速度和 SEO 性能。</li><li><strong>静态站点生成（SSG）</strong>：允许在构建时生成静态页面，适合博客或文档类项目。</li><li><strong>自动化路由</strong>：Next.js 提供了文件系统为基础的路由，开发者无需手动配置路由。</li><li><strong>API 路由</strong>：可以创建后端 API，轻松搭建全栈项目。</li><li><strong>强大的数据获取能力</strong>：通过 <code>getStaticProps</code>、<code>getServerSideProps</code>、<code>getStaticPaths</code>，实现不同场景的数据获取方式。</li><li><strong>全栈能力</strong>：支持服务端渲染和静态生成，结合 API 路由，可以做出全栈应用。</li><li><strong>零配置</strong>：无需配置复杂的打包工具，开箱即用。</li><li><strong>开发体验友好</strong>：热更新、自动路由、编译和开发服务器快速启动等功能让开发体验更加高效。</li></ul><h1 id="3-Next-js-与其他框架的对比"><a href="#3-Next-js-与其他框架的对比" class="headerlink" title="3. Next.js 与其他框架的对比"></a>3. Next.js 与其他框架的对比</h1><h2 id="Next-js-VS-React"><a href="#Next-js-VS-React" class="headerlink" title="Next.js VS React"></a>Next.js VS React</h2><ul><li>react 本身是不支持服务端渲染和静态生成的，需要其他库的帮助，例如 Gatsby，而 Next.js 原生就能够支持这些。</li><li>对于路由方面的支持，React 需要借助 <code>react-router</code> 配置路由，Next.js 的文件系统路由就显得更加简单</li><li>React 只能用于处理前端逻辑，但是 Next.js 是一个可以处理全栈的（但是事实上在实际工作中，项目中基本还是归于前端的活，后端肯定还是 java 最多了）</li></ul><h2 id="Next-js-vs-Nuxt-js"><a href="#Next-js-vs-Nuxt-js" class="headerlink" title="Next.js vs Nuxt.js"></a>Next.js vs Nuxt.js</h2><ul><li>Next.js 是 React 生态的一部分，而 Nuxt.js 则是 Vue 生态的强大框架，两者在生态的选择上差异较大（非常简单，会哪个用哪个，两个都非常好用）</li><li>Next.js 和 Nuxt.js 都提供了 SSR 支持，但 Next.js 社区更加庞大，生态系统丰富。</li></ul><h2 id="Next-js-vs-Vue-js"><a href="#Next-js-vs-Vue-js" class="headerlink" title="Next.js vs Vue.js"></a>Next.js vs Vue.js</h2><ul><li><p>Vue.js 是一个 MVVM 模式的前端框架（在这里就要插一嘴了，什么是 mvvm 模式在我的《<a href="https://www.xixiking.com/2024/07/25/%E9%9D%A2%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">面试注意事项</a>》中我记得有过记录，这些内容一般面试经常问），主要用于单页应用开发；Next.js 是全栈框架，具有更多的全局路由管理、数据获取和 SSR 支持。</p></li><li><p>Vue.js 的语法和数据双向绑定更加友好，但 Next.js 的文件路由和强大数据获取更适合大型项。</p></li></ul><h1 id="4-Next-js-的项目结构介绍"><a href="#4-Next-js-的项目结构介绍" class="headerlink" title="4. Next.js 的项目结构介绍"></a>4. Next.js 的项目结构介绍</h1><p>​ 对于不同版本的 Next.js 项目，目录文件夹的名字会有些许的差异，就比如用来存放静态资源的文件夹 static，在目前最新版的 Next.js 项目目录中已经改名为了 public，还有一些相较于旧版本没有的 next.config.js（Next.js 配置文件），tsconfig.json（TypeScript 配置文件）配置文件等等，现在其实还是采用最新版的比较好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my-next-app/</span><br><span class="line">├── app/               <span class="comment"># App 目录，存放应用页面和布局</span></span><br><span class="line">├── public/            <span class="comment"># 公共静态资源目录，直接可访问的文件</span></span><br><span class="line">├── pages/             <span class="comment"># 页面目录，自动化路由生成</span></span><br><span class="line">│   └── api/           <span class="comment"># API 路由存放处</span></span><br><span class="line">├── styles/            <span class="comment"># 样式文件目录</span></span><br><span class="line">├── next.config.js     <span class="comment"># Next.js 配置文件</span></span><br><span class="line">├── package.json       <span class="comment"># 项目依赖管理</span></span><br><span class="line">└── tsconfig.json      <span class="comment"># TypeScript 配置文件（可选）</span></span><br></pre></td></tr></table></figure><ul><li><p><strong><code>pages/</code></strong>：该目录下的文件自动成为路由，例如 <code>pages/index.js</code> 对应 <code>/</code> 路径。</p></li><li><p><strong><code>pages/api/</code></strong>：用于创建 API 路由，生成后端逻辑和 API 接口。</p></li><li><p><strong><code>public/</code></strong>：存放静态文件，如图片、字体等，这些文件可以通过 URL 直接访问。</p></li><li><p><strong><code>styles/</code></strong>：用于存放 CSS 文件，按模块划分更清晰。</p></li><li><p><strong><code>next.config.js</code></strong>：项目的配置文件，可以配置自定义的构建选项、路由设置等。</p></li></ul><h1 id="5-创建-Next-js-项目"><a href="#5-创建-Next-js-项目" class="headerlink" title="5. 创建 Next.js 项目"></a>5. 创建 Next.js 项目</h1><h2 id="1-首先官方推荐的脚手架工具是-create-next-app，并且推荐用-npx-来创建，用-npm、yarn-同样也是-ok-的"><a href="#1-首先官方推荐的脚手架工具是-create-next-app，并且推荐用-npx-来创建，用-npm、yarn-同样也是-ok-的" class="headerlink" title="1. 首先官方推荐的脚手架工具是 create-next-app，并且推荐用 npx 来创建，用 npm、yarn 同样也是 ok 的"></a>1. 首先官方推荐的脚手架工具是 create-next-app，并且推荐用 npx 来创建，用 npm、yarn 同样也是 ok 的</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest my-next-app</span><br></pre></td></tr></table></figure><p>（这里的@latest 是指下载最新版本的意思，这个我自己在创建 Vue3 项目的时候也使用过很多次)</p><h2 id="2-配置-TypeScript（可选）-如果你想在项目中使用-TypeScript，可以在项目初始化后安装-TypeScript-依赖："><a href="#2-配置-TypeScript（可选）-如果你想在项目中使用-TypeScript，可以在项目初始化后安装-TypeScript-依赖：" class="headerlink" title="2. 配置 TypeScript（可选） 如果你想在项目中使用 TypeScript，可以在项目初始化后安装 TypeScript 依赖："></a>2. <strong>配置 TypeScript（可选）</strong> 如果你想在项目中使用 TypeScript，可以在项目初始化后安装 TypeScript 依赖：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript @types/react @types/node</span><br></pre></td></tr></table></figure><h2 id="3-运行开发服务器-进入项目文件夹并启动开发服务器："><a href="#3-运行开发服务器-进入项目文件夹并启动开发服务器：" class="headerlink" title="3. 运行开发服务器 进入项目文件夹并启动开发服务器："></a>3. <strong>运行开发服务器</strong> 进入项目文件夹并启动开发服务器：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-next-app</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>服务器会默认应该会启动本地的 3000 端口号，可以看到欢迎界面</p><h1 id="6-补充细节"><a href="#6-补充细节" class="headerlink" title="6. 补充细节"></a>6. 补充细节</h1><h2 id="1-单页面应用（SPA）-vs-多页面应用（MPA）"><a href="#1-单页面应用（SPA）-vs-多页面应用（MPA）" class="headerlink" title="1. 单页面应用（SPA） vs 多页面应用（MPA）"></a>1. 单页面应用（SPA） vs 多页面应用（MPA）</h2><ul><li><p>SPA 是指整个应用只有一个 HTML 文件，当用户访问不同的页面时，前端框架通过 JavaScript 动态更新页面内容，而不需要从服务器重新请求页面。Vue 和 React 等框架非常适合构建 SPA。</p><ul><li><strong>流畅的用户体验</strong>：页面内容切换无需重新加载整个页面，所有页面通过 JavaScript 更新，体验更流畅。</li><li><strong>前后端分离</strong>：前端负责处理视图渲染，后端只提供数据接口（API），便于前后端分离开发。</li><li><strong>减少服务器请求</strong>：页面切换时无需重新加载所有资源（如 CSS、JS 等），减少了 HTTP 请求次数。</li><li><strong>初次加载时间较长</strong>：由于所有页面资源都被打包到一个文件中，初次加载时需要加载大量内容，影响首次加载速度。</li><li><strong>SEO 不友好</strong>：因为大部分内容由 JavaScript 动态渲染，传统的搜索引擎爬虫难以抓取页面内容，不利于 SEO（可以通过 SSR 来优化）。</li><li><strong>复杂的前端路由</strong>：SPA 需要使用前端路由库（如 <code>vue-router</code> 或 <code>react-router</code>）来管理页面跳转和状态维护，增加了复杂度。</li></ul></li><li><p>MPA 是指每个页面都有自己独立的 HTML 文件，当用户访问不同页面时，浏览器会从服务器获取并重新加载一个新的 HTML 页面。传统的 Web 开发模式（如基于 PHP、JSP、ASP.NET 等的开发）通常是 MPA。</p><ul><li><p><strong>SEO 友好</strong>：每个页面都由服务器生成，搜索引擎能够轻松爬取页面内容，从而提升 SEO。</p></li><li><p><strong>更快的首屏加载</strong>：每个页面的资源独立加载，首次加载时只需加载当前页面所需资源，相对较快。</p></li><li><p><strong>安全性更高</strong>：由于每次页面加载时都会从服务器请求新的 HTML 文件，安全性相对较好。</p></li><li><p><strong>用户体验较差</strong>：每次页面切换时，浏览器都会重新加载 HTML 和资源，导致页面闪烁和延迟，影响用户体验。</p><p>（确实我在做公司的 next 项目的时候能够体会到，所有资源在初次加载的时候都会比较费时，有种路由懒加载的感觉，尤其是当我的项目需要解析路由，解析配置，或者说配置了一些比较复杂的中间件的时候都会影响到页面资源的加载速度）</p></li><li><p><strong>重复加载资源</strong>：在不同页面间跳转时，每次都需要重新加载 CSS、JS 等静态资源，浪费带宽和服务器资源。</p><p>（这个确实是可以在控制台看到的效果，但是不知道是不是有缓存的缘故，首次加载是会很慢的，但是之后再访问就还是挺快的，和单页面没有太大区别）</p></li></ul></li></ul><p>​ 值得一提的是在我实习的过程中，真的是深刻体会到了单页面和多页面的区别，由于我平时还会做一些内嵌进 App 的 html5 项目，这就需要将需要的页面都独立出来，我公司的方案是将每个 h5 页面都分别配置，将单页面应用到多页面场景中，实在是资源非常难以得到复用，但是毕竟要内嵌进 App 中，页面就必须得是独立的（说白了就是还是沿用了之前的老项目的框架，也就是将 vue2 换成了 vue3 而已（我的猜测），看得出来大家都喜欢偷懒 😂</p><h2 id="2-App-Router-和-Page-Router（待补充）"><a href="#2-App-Router-和-Page-Router（待补充）" class="headerlink" title="2. App Router 和 Page Router（待补充）"></a>2. App Router 和 Page Router（待补充）</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Next.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的文章</title>
      <link href="/2024/10/01/%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/01/%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<ol><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/25/hello-world/"/>
      <url>/2024/09/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试注意事项</title>
      <link href="/2024/07/25/%E9%9D%A2%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2024/07/25/%E9%9D%A2%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>​ 简单介绍自己的情况，自己的技术和项目，其他不用</p><h6 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h6><ul><li>登录身份验证机制</li><li>轮询机制替代 WebSocket</li><li>异步控制请求</li><li>防抖、节流、图片懒加载</li></ul><h3 id="2-提问-hr"><a href="#2-提问-hr" class="headerlink" title="2. 提问 hr"></a>2. 提问 hr</h3><p>​ 实习期间公司是否有针对实习生的培训机制？</p><p>​ 实习期间如果学校有急事是否可以请假申请？</p><p>​ 实习期间是否有绩效考核？</p><p>​ 大概多久可以收到通知？</p><h3 id="3-JavaScript"><a href="#3-JavaScript" class="headerlink" title="3. JavaScript"></a>3. JavaScript</h3><h6 id="3-1-对象（Object）"><a href="#3-1-对象（Object）" class="headerlink" title="3.1 对象（Object）"></a>3.1 对象（Object）</h6><p>对象是 JavaScript 里的一种数据类型，比数组描述更加详细，能够描述具体的事物</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="attr">name</span>:string,</span><br><span class="line">    <span class="attr">num</span>:number.</span><br><span class="line">    <span class="attr">boolean</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">function</span>: <span class="title function_">fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">let</span> object = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="comment">//or 构造函数创建对象(只能用new来执行，命名必须大写 )</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Obj</span>(string, number);</span><br></pre></td></tr></table></figure><h6 id="3-2-作用域"><a href="#3-2-作用域" class="headerlink" title="3.2 作用域"></a>3.2 作用域</h6><p>作用域规定了变量的访问范围</p><p>局部作用域（函数作用域和块作用域）：外部不能访问</p><p>全局作用域：可以在任意作用域被访问</p><p>作用域链：当多个作用域嵌套时串联形成了作用域链，子作用域可以访问父作用域，反之不可以</p><h6 id="3-3-垃圾回收机制（GC）"><a href="#3-3-垃圾回收机制（GC）" class="headerlink" title="3.3 垃圾回收机制（GC）"></a>3.3 垃圾回收机制（GC）</h6><p>js 内存分配生命周期：内存分配—&gt;内存使用—&gt;内存回收（GC）</p><p>垃圾回收：全局变量一般不会回收，局部变量在不用的时候会自动回收</p><p>垃圾回收机制：一般用来回收复杂数据类型</p><p>算法说明：</p><ol><li><p>跟踪记录被引用的次数</p></li><li><p>如果引用了就记录++</p></li><li><p>如果减少了就记录—</p></li><li>如果引用为 0 则释放内存</li></ol><p>注意：如果对象之间嵌套引用会引发内存泄漏</p><h6 id="3-4-闭包"><a href="#3-4-闭包" class="headerlink" title="3.4 闭包"></a>3.4 闭包</h6><p>一个函数对周围状态的引用捆绑在一起，内部函数访问其外层函数的作用域 （内层函数+外层函数的变量）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">fn</span>(); <span class="comment">// result 现在是 fn1 函数的引用</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出: 1</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出: 2</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><h6 id="3-5-箭头函数"><a href="#3-5-箭头函数" class="headerlink" title="3.5 箭头函数"></a>3.5 箭头函数</h6><ul><li><strong>没有自己的 this</strong>：箭头函数不会创建自己的 <code>this</code>，它的 <code>this</code> 值取决于它所在的上下文（也就是定义时的 <code>this</code>），而不是调用时的 <code>this</code>。这使得箭头函数特别适合用作回调函数和需要保持上下文 <code>this</code> 的场景。</li><li><strong>没有 <code>arguments</code> 对象</strong>：箭头函数不绑定 <code>arguments</code> 对象，如果需要访问参数，可以使用剩余参数语法 <code>...args</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalFunction = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFunction</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments 对象，包含函数调用时传递的所有参数</span></span><br><span class="line"><span class="title function_">normalFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出 [1, 2, 3]</span></span><br><span class="line"><span class="title function_">arrowFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li><strong>不可作为构造函数使用</strong>：由于箭头函数没有自己的 <code>this</code>，它不能作为构造函数使用，不能使用 <code>new</code> 关键字调用。</li><li><strong>不能使用 <code>yield</code></strong>：箭头函数不能用作生成器函数，不能使用 <code>yield</code> 关键字。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">// 只有一个形参的时候可以省略括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 只有一行函数的时候可以省略大括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 只有一行返回时可以省略return</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>) =&gt; x++;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 直接返回对象(需要加小括号)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">name</span>) =&gt; (&#123; <span class="attr">name</span>: name &#125;);</span><br></pre></td></tr></table></figure><h6 id="3-6-解构赋值"><a href="#3-6-解构赋值" class="headerlink" title="3.6 解构赋值"></a>3.6 解构赋值</h6><ol><li>数组解构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组赋值</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [str1, str2, str3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [str1, str2, str3] = arr;</span><br><span class="line"><span class="comment">// 交换变量的值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>; <span class="comment">// 必须加分号</span></span><br><span class="line">[b, a] = [a, b](</span><br><span class="line">  <span class="comment">// 两种必须加分号的情况</span></span><br><span class="line">  <span class="comment">// 1. 立即执行函数</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">)();</span><br><span class="line"><span class="comment">// 2. 使用数组时</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b];</span><br><span class="line"><span class="comment">// 所以我建议还是全部加分号吧</span></span><br></pre></td></tr></table></figure><ol><li>对象结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:string,</span><br><span class="line">    <span class="attr">age</span>:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name, age&#125; = &#123;<span class="attr">name</span>:string, <span class="attr">age</span>:number&#125;; <span class="comment">// 变量名必须和属性名一样</span></span><br><span class="line"><span class="title function_">const</span> (&#123;name, age&#125;) = obj;</span><br></pre></td></tr></table></figure><h6 id="3-7-new-实例化"><a href="#3-7-new-实例化" class="headerlink" title="3.7 new 实例化"></a>3.7 new 实例化</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;XXX&quot;</span>; <span class="comment">// =</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置构造函数Objcect, Array, String, Boolean</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(string, number);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(); <span class="comment">// 获取对象中的所有属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(); <span class="comment">// 获取所有的值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(newobj, obj); <span class="comment">// 将obj拷贝给newobj</span></span><br></pre></td></tr></table></figure><h6 id="3-8-原型和原型链"><a href="#3-8-原型和原型链" class="headerlink" title="3.8 原型和原型链"></a>3.8 原型和原型链</h6><p>原型：</p><ul><li>在 JavaScript 中，每个对象都有一个与之关联的另一个对象，这个对象就是原型。原型对象可以包含这个对象的所有属性和方法，这样通过继承的方式，其他对象就可以使用这些属性和方法。</li><li><strong><code>__proto__</code> 属性</strong>：这是每个对象都有的一个内部属性，用于指向其原型。这个属性在一些 JavaScript 引擎中实现为 <code>[[Prototype]]</code>，但是大多数浏览器都提供了 <code>__proto__</code> 属性来访问这个内部属性。</li><li><strong><code>prototype</code> 属性</strong>：这是构造函数的一个属性，指向一个对象，所有通过该构造函数创建的实例对象都会共享这个原型对象。</li><li><strong>属性查找</strong>：当访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript 引擎会查找该对象的原型，依此类推，直到找到属性或者达到原型链的末尾（即 <code>Object.prototype</code>）为止。</li><li><strong>实现继承</strong>：原型是 JavaScript 实现继承的基础。通过设置一个对象的 <code>__proto__</code> 属性为另一个对象，实现属性和方法的继承</li><li><strong>共享方法和属性</strong>：通过原型，多个对象可以共享同一个方法或属性，避免了在每个实例上都定义相同的方法或属性的情况</li></ul><p>原型链：</p><ul><li>原型链是由多个对象通过其 <code>__proto__</code> 属性相互连接形成的链式结构，用于实现属性和方法的继承。在 JavaScript 中，对象的属性查找过程就是沿着原型链进行的</li><li><strong>链式结构</strong>：每个对象的 <code>__proto__</code> 属性指向其构造函数的 <code>prototype</code> 属性，从而形成一个链式结构，最终指向 <code>Object.prototype</code>。</li><li><strong>属性查找</strong>：当访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript 引擎会沿着原型链向上查找，直到找到属性或达到原型链的末尾。</li></ul><h6 id="3-9-浅拷贝"><a href="#3-9-浅拷贝" class="headerlink" title="3.9 浅拷贝"></a>3.9 浅拷贝</h6><p>为什么拷贝对象的时候，改变赋值对象的值也会影响原来对象的值？</p><p>答：因为 js 中对象是通过引用而不是通过值来进行赋值的，即变量中存储的是对象在内存中的地址</p><ul><li><p>浅拷贝只复制对象的第一层属性，如果属性是一个对象，则复制的是该对象的引用，而不是对象本身</p></li><li><p>浅拷贝仅复制对象的第一层。对嵌套的对象或数组中的元素进行任何修改，都会反映在原始对象上</p></li><li><p>浅拷贝方法：</p><ul><li>Object.assign()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><ul><li>展开运算符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = &#123; ...obj &#125;;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><ul><li>slice()、concat()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> copy = arr.<span class="title function_">slice</span>();</span><br><span class="line">copy[<span class="number">2</span>].<span class="property">a</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">2</span>].<span class="property">a</span>); <span class="comment">// 输出: 4</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="3-10-深拷贝"><a href="#3-10-深拷贝" class="headerlink" title="3.10 深拷贝"></a>3.10 深拷贝</h6><ul><li>深拷贝会递归复制对象中的所有属性，创建一个完全独立的对象副本。修改深拷贝后的对象不会影响原始对象，即使嵌套了多个层级的对象或数组</li><li>深拷贝方法：<ul><li>JSON（局限：不能复制函数、<code>Date</code>、<code>RegExp</code> 等特殊对象类型）</li><li>递归</li><li><code>lodash</code> 库的 <code>_.cloneDeep</code> 方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> copy = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            copy[key] = <span class="title function_">deepCopy</span>(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">deepCopy</span>(obj);</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lodash/cloneDeep</span></span><br><span class="line"><span class="keyword">const</span> <span class="number">0</span> = _.<span class="title function_">cloneDeep</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(obj)  <span class="comment">// 将对象转为json</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(obj))  <span class="comment">// 将json转换为对象</span></span><br></pre></td></tr></table></figure><h6 id="3-11-防抖"><a href="#3-11-防抖" class="headerlink" title="3.11 防抖"></a>3.11 防抖</h6><p>单位时间内，频繁触发事件，只执行一次，防抖可以减少卡顿</p><p>防抖是最后一次触发后延时执行</p><p>案例：用户输入完毕才请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lodash库实现防抖</span></span><br><span class="line">_.<span class="title function_">debounce</span>(<span class="keyword">function</span>, time)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手搓</span></span><br><span class="line"><span class="comment">// 1.声明定时器</span></span><br><span class="line"><span class="comment">// 2.出发事件，先判断是否有定时器，如果有先清除以前的</span></span><br><span class="line"><span class="comment">// 3.如果没有，则开启定时器</span></span><br></pre></td></tr></table></figure><h6 id="3-12-节流"><a href="#3-12-节流" class="headerlink" title="3.12 节流"></a>3.12 节流</h6><p>单位时间内，频繁触发事件，只执行一次</p><p>节流是第一次触发后延时结束</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lodash</span></span><br><span class="line">_.<span class="title function_">throttle</span>(<span class="keyword">function</span>, time)</span><br><span class="line"><span class="comment">// 手搓</span></span><br></pre></td></tr></table></figure><h6 id="3-13-继承"><a href="#3-13-继承" class="headerlink" title="3.13 继承"></a>3.13 继承</h6><p>继承是一种允许一个对象（子类或派生类）使用另一个对象（父类或基类）的属性和方法的能力</p><p>原型链继承、构造函数继承、组合继承</p><p>在 ES6 中，<code>class</code>关键字和<code>extends</code>关键字被引入作为继承语法</p><h6 id="3-14-类"><a href="#3-14-类" class="headerlink" title="3.14 类"></a>3.14 类</h6><p>class</p><h6 id="3-15-ES6-和-ES7-的新特性和语法"><a href="#3-15-ES6-和-ES7-的新特性和语法" class="headerlink" title="3.15 ES6 和 ES7 的新特性和语法"></a>3.15 ES6 和 ES7 的新特性和语法</h6><p>ES6</p><ol><li>块级作用域<ul><li>引入了<code>let</code>和<code>const</code>关键字，允许在块级作用域（例如代码块或<code>&#123;&#125;</code>内部）中声明变量和常量。</li><li><code>let</code>声明的变量具有块级作用域，解决了传统<code>var</code>声明的变量提升问题。</li><li><code>const</code>声明的常量是只读的，一旦赋值后不能再次修改。</li></ul></li><li>箭头函数<ul><li>提供了一种更简洁的函数声明方式，使用<code>=&gt;</code>代替传统的<code>function</code>关键字。</li><li>箭头函数没有自己的<code>this</code>、<code>arguments</code>、<code>super</code>或<code>new.target</code>，它们会捕获其所在上下文的这些值。这使得箭头函数在回调函数中特别有用，因为它们不会改变<code>this</code>的指向。</li></ul></li><li>解构赋值<ul><li>允许从数组或对象中提取值并赋值给变量。</li><li>提供了简洁的语法来访问数组元素或对象属性。</li></ul></li><li>默认参数<ul><li>允许在函数定义时为参数提供默认值。</li><li>如果调用函数时未提供某个参数，则使用默认值。</li></ul></li><li>扩展运算符（Spread Operator）<ul><li>使用<code>...</code>语法，可以将数组或对象展开为独立的元素或属性。</li><li>常用于函数调用、数组字面量或对象字面量中。</li></ul></li><li>模板字符串<ul><li>使用反引号（```）定义字符串，并支持变量插值和多行字符串。</li><li>提高了代码的可读性和可维护性。</li></ul></li><li>类和模块<ul><li>引入了<code>class</code>关键字作为面向对象编程的语法糖。</li><li>提供了<code>extends</code>和<code>super</code>关键字来实现类的继承。</li><li>引入了模块化的概念，通过<code>import</code>和<code>export</code>关键字可以方便地导入和导出模块。</li></ul></li><li>Promise 对象和 async/await<ul><li>Promise 是处理异步操作的一种模式，它代表了一个最终可能完成（也可能被拒绝）的异步操作及其结果值。</li><li><code>async/await</code>是基于 Promise 的异步编程解决方案，使得异步代码看起来像同步代码一样，更加直观易读。</li></ul></li></ol><p>此外，ES6 还引入了迭代器（Iterator）、生成器（Generator）等其他特性，这些特性为处理集合和异步编程提供了更强大的支持。</p><p>ES7</p><ol><li>Array.prototype.includes()方法<ul><li>这是一个新的数组方法，用于检测一个数组是否包含一个特定的值，返回值为布尔类型。</li><li>与<code>indexOf()</code>方法相比，<code>includes()</code>方法对于<code>NaN</code>的处理更加合理，且语法更加简洁。</li></ul></li><li>幂运算符（<ul><li>引入了新的幂运算符<code>**</code>，用于计算一个数的乘方。</li><li>例如，<code>2 ** 3</code>将返回<code>8</code>。</li></ul></li></ol><h6 id="3-16-回调函数"><a href="#3-16-回调函数" class="headerlink" title="3.16 回调函数"></a>3.16 回调函数</h6><ul><li><p>将函数作为参数传递给另一个函数来异步执行，回调函数会在异步操作后被掉用。</p></li><li><p>易于产生回调地狱（Callback Hell），导致代码难以维护和阅读。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123; <span class="attr">message</span>: <span class="string">&quot;Hello, World!&quot;</span> &#125;;</span><br><span class="line">    <span class="title function_">callback</span>(data);</span><br><span class="line">  &#125;, <span class="number">1000</span>); <span class="comment">// 模拟1秒的异步操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">message</span>); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="3-17-promise"><a href="#3-17-promise" class="headerlink" title="3.17 promise"></a>3.17 promise</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> success = <span class="literal">true</span>; <span class="comment">// 模拟成功或失败</span></span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123; <span class="attr">message</span>: <span class="string">&quot;Hello, World!&quot;</span> &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Failed to fetch data&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">message</span>); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>); <span class="comment">// 输出: Failed to fetch data</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h6 id="3-18-数据类型"><a href="#3-18-数据类型" class="headerlink" title="3.18 数据类型"></a>3.18 数据类型</h6><ul><li>基本数据类型<ul><li>String：表示一系列字符的文本数据</li><li>Number：表示整数或浮点数</li><li>BigInt：用于表示大于 <code>Number.MAX_SAFE_INTEGER</code> 的整数</li><li>Boolean：表示 <code>true</code> 或 <code>false</code></li><li>Undefined：表示一个变量尚未被赋值（声明但未初始化）</li><li>Null：表示一个空值或无值</li><li>Symbol：表示唯一的标识符</li></ul></li><li>复杂数据类型（引用数据类型）<ul><li>Object：表示一组键值对，其中键是字符串或 Symbol，值可以是任意数据类型</li><li>Array：表示一组有序的数据，数组是对象的一种特殊形式</li><li>Function：表示一段可重复执行的代码，函数也是对象</li><li>Date：表示日期和时间</li><li>RegExp：表示正则表达式模式，用于字符串匹配和替换</li></ul></li></ul><h6 id="3-19-let-var-const"><a href="#3-19-let-var-const" class="headerlink" title="3.19 let\var\const"></a>3.19 let\var\const</h6><div class="table-container"><table><thead><tr><th>特性</th><th><code>var</code></th><th><code>let</code></th><th><code>const</code></th></tr></thead><tbody><tr><td>作用域</td><td>函数作用域</td><td>块作用域</td><td>块作用域</td></tr><tr><td>变量提升</td><td>声明会提升，初始化为 <code>undefined</code></td><td>声明会提升，但在 TDZ 中无法访问</td><td>声明会提升，但在 TDZ 中无法访问</td></tr><tr><td>重复声明</td><td>允许</td><td>不允许</td><td>不允许</td></tr><tr><td>初始化</td><td>可选</td><td>可选</td><td>必须在声明时初始化</td></tr><tr><td>可变性</td><td>允许重新赋值</td><td>允许重新赋值</td><td>不允许重新赋值</td></tr><tr><td>全局对象的属性</td><td>是</td><td>否</td><td>否</td></tr></tbody></table></div><h3 id="4-vue"><a href="#4-vue" class="headerlink" title="4. vue"></a>4. vue</h3><h6 id="4-1-各个生命周期需要干的事"><a href="#4-1-各个生命周期需要干的事" class="headerlink" title="4.1 各个生命周期需要干的事"></a>4.1 各个生命周期需要干的事</h6><p>beforeCreate：初始化实例，调用事件和函数（可以查看一下环境变量和初始数据，dom 也没有渲染）</p><p>Created：实例完成对选项的处理，函数和数据都被配置完毕（可以获取数据，但是 dom 节点没有渲染）</p><p>beforeMount：render 函数首次调用（可以获取数据，dom 没有渲染）</p><p>Mounted：实例挂在后被调用（dom 渲染完毕）</p><p>beforeUpdate：数据变化时，获取变化前的 dom</p><p>updated：dom 已经更新</p><p>beforeDestroy：销毁之前，实例还在（可以做一些善后的工作，例如清除一些事件）</p><p>Destroy：销毁完成，实例丧失功能</p><h6 id="4-2-keep-alive"><a href="#4-2-keep-alive" class="headerlink" title="4.2 keep-alive"></a>4.2 keep-alive</h6><p>一个 vue 内置组件，主要用于缓存组件实例，避免组件重复的被创建和销毁组件，提高应用的响应速度和性能。</p><p>提供了两个新的生命周期钩子：</p><p><strong>**activated：**</strong>当组件被激活（使用）的时候触发，常用于执行一些数据初始化或者异步操作，在 mounted 后面触发；</p><p><strong>*deactivated：*</strong>当组件失活（不被使用）的时候触发；</p><h6 id="4-3-ref"><a href="#4-3-ref" class="headerlink" title="4.3 ref"></a>4.3 ref</h6><ol><li>用于声明响应式数据</li><li>用于获取 dom</li></ol><h6 id="4-4-nextTick"><a href="#4-4-nextTick" class="headerlink" title="4.4 nextTick"></a>4.4 nextTick</h6><p>用于获取更新后的 dom，在 dom 更新结束后执行延迟回调（进行异步操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div ref=&quot;msgDiv&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-if=&quot;msg1&quot;&gt;Message got outside $nextTick: &#123;&#123; msg1 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-if=&quot;msg2&quot;&gt;Message got inside $nextTick: &#123;&#123; msg2 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-if=&quot;msg3&quot;&gt;Message got outside $nextTick: &#123;&#123; msg3 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;button @click=&quot;changeMsg&quot;&gt;改变 Msg &lt;/button&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;.app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: &#x27;Hello Vue.&#x27;,</span><br><span class="line">    msg1: &#x27;&#x27;,</span><br><span class="line">    msg2: &#x27;&#x27;,</span><br><span class="line">    msg3: &#x27;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeMsg() &#123;</span><br><span class="line">      this.msg = &quot;Hello world.&quot;</span><br><span class="line">      this.msg1 = this.$refs.msgDiv.innerHTML</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.msg2 = this.$refs.msgDiv.innerHTML</span><br><span class="line">      &#125;)</span><br><span class="line">      this.msg3 = this.$refs.msgDiv.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="4-5-计算属性"><a href="#4-5-计算属性" class="headerlink" title="4.5 计算属性"></a>4.5 计算属性</h6><ol><li><strong>简化模板逻辑</strong>：在模板中直接使用复杂表达式可能会使模板变得难以阅读和维护。通过使用计算属性，你可以将这些复杂逻辑移出模板，并将它们封装在可重用的计算属性中。</li><li><strong>依赖缓存</strong>：计算属性是基于它们的响应式依赖进行缓存的。这意味着只要依赖没有发生变化，计算属性就不会重新计算，从而提高了性能。这与方法不同，方法每次被调用时都会重新执行。</li><li><strong>可重用性</strong>：计算属性可以在组件的多个地方被重用，而无需重复编写相同的逻辑。</li><li><strong>更易于测试</strong>：由于计算属性是可重用的，并且与模板逻辑分离，因此它们更易于进行单元测试。</li><li><strong>减少性能开销</strong>：由于计算属性是基于依赖进行缓存的，因此当依赖没有发生变化时，它们不会触发不必要的重新渲染或计算，从而减少了性能开销。</li><li><strong>提高可读性</strong>：通过将复杂的逻辑封装在计算属性中，你可以使模板更加简洁和易于阅读</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;原始值：&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;计算后的值（首字母大写）：&#123;&#123; upperCaseMessage &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;hello vue!&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性</span><br><span class="line">    upperCaseMessage() &#123;</span><br><span class="line">      return this.message.toUpperCase();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="4-6-组件通信"><a href="#4-6-组件通信" class="headerlink" title="4.6 组件通信"></a>4.6 组件通信</h6><ol><li>props：父传子</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件，&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">import Child from &quot;./Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">// 数据</span><br><span class="line">const car = ref(&quot;奔驰&quot;);</span><br><span class="line">const toy = ref();</span><br><span class="line">// 方法</span><br><span class="line">function getToy(value: string) &#123;</span><br><span class="line">  toy.value = value;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const toy = ref(&quot;奥特曼&quot;);</span><br><span class="line"></span><br><span class="line">defineProps([&quot;car&quot;, &quot;getToy&quot;]);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>emit、 $event ：子传父</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span><br><span class="line">&lt;Child @send-toy=&quot;toy = $event&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span><br><span class="line">&lt;button @click=&quot;toy = $event&quot;&gt;测试&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">//子组件中，触发事件： this.$emit(&#x27;send-toy&#x27;, 具体数据)</span><br></pre></td></tr></table></figure><ol><li><p>mitt：实现任意组件通信 npm i mitt</p></li><li><p>v-model：父子相互通信</p></li><li>$attrs：祖孙通信</li><li>ref、parent：父子、子父</li><li>provide、inject：祖孙通信</li><li>pinia：任意组件</li><li>slot：父子通信</li></ol><h6 id="4-7-路由"><a href="#4-7-路由" class="headerlink" title="4.7 路由"></a>4.7 路由</h6><p>hash 模式：兼容性好，有#，seo 优化</p><p>history 模式：简洁美观，需要后端服务器配合，有时候需要重定向</p><p>replace 模式：替换当前记录（和浏览器是否支持页面回退有关）</p><p>push：追加历史记录（和浏览器是否支持页面回退有关）</p><p>一些参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// query查询参数</span><br><span class="line">&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;</span><br><span class="line">&lt;router-link to=&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;&gt;</span><br><span class="line">跳转</span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;</span><br><span class="line">&lt;RouterLink</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    //name:&#x27;xiang&#x27;, //用name也可以跳转</span><br><span class="line">    path: &#x27;/news/detail&#x27;,</span><br><span class="line">    query: &#123;</span><br><span class="line">      id: news.id,</span><br><span class="line">      title: news.title,</span><br><span class="line">      content: news.content,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// params普通传参</span><br><span class="line">&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;</span><br><span class="line">&lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;&#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;</span><br><span class="line">&lt;RouterLink</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    name: &#x27;xiang&#x27;, //用name跳转</span><br><span class="line">    params: &#123;</span><br><span class="line">      id: news.id,</span><br><span class="line">      title: news.title,</span><br><span class="line">      content: news.title,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure><h6 id="4-8-响应式原理"><a href="#4-8-响应式原理" class="headerlink" title="4.8 响应式原理"></a>4.8 响应式原理</h6><p>vue2</p><ol><li><strong>MVVM 模式</strong>：Vue 2 的响应式原理基于 MVVM（Model-View-ViewModel）设计模式。在此模式中，ViewModel 是连接视图（View）和数据模型（Model）的桥梁，它负责将数据模型的变化映射到视图上，并在视图上触发事件时更新数据模型。</li><li><strong>Object.defineProperty()</strong>：Vue 2 使用<code>Object.defineProperty()</code>方法来实现响应式。具体来说，Vue 在初始化过程中会遍历 data 对象的所有属性，并使用<code>Object.defineProperty()</code>将这些属性转换成 getter 和 setter。这样，当数据模型发生变化时（即属性被读取或修改），Vue 就能够通过 getter 和 setter 捕获这些变化，并触发视图的更新。</li></ol><p>vue3</p><ol><li><strong>Proxy 对象</strong>：Vue 3 使用 ES6 中的 Proxy 对象来实现响应式。Proxy 可以拦截对象的操作，包括属性读取、赋值、删除等，这使得 Vue 能够监听到对象的变化并做出相应的响应。</li><li><strong>Reactive API</strong>：Vue 3 提供了一套 Reactive API 来创建响应式的数据对象。通过调用<code>reactive()</code>函数，可以将一个普通的 JavaScript 对象转换成响应式的对象。当对象发生变化时，Vue 能够检测到并更新相应的视图。</li></ol><div class="table-container"><table><thead><tr><th>特性</th><th>Vue 2</th><th>Vue 3</th></tr></thead><tbody><tr><td>响应式实现</td><td><code>Object.defineProperty</code></td><td><code>Proxy</code></td></tr><tr><td>动态属性检测</td><td>不支持</td><td>支持</td></tr><tr><td>数组操作检测</td><td>部分支持（通过特定方法）</td><td>完全支持</td></tr><tr><td>深层嵌套对象</td><td>递归处理，性能较差</td><td>性能更好，自动处理所有层级</td></tr><tr><td>依赖收集与更新派发</td><td>手动收集，较为复杂</td><td>自动收集，逻辑简单</td></tr><tr><td>新的响应式 API</td><td>不支持</td><td><code>reactive</code>, <code>ref</code>, <code>computed</code>, etc.</td></tr></tbody></table></div><h6 id="4-9-图片懒加载"><a href="#4-9-图片懒加载" class="headerlink" title="4.9 图片懒加载"></a>4.9 图片懒加载</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DirectiveBinding</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lazyLoadImage = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el: HTMLImageElement, binding: DirectiveBinding</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建 IntersectionObserver 实例</span></span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">      entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">          <span class="comment">// 图片进入视口，设置图片的 src 属性</span></span><br><span class="line">          el.<span class="property">src</span> = binding.<span class="property">value</span>;</span><br><span class="line">          observer.<span class="title function_">unobserve</span>(el); <span class="comment">// 停止观察该图片元素</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始观察元素</span></span><br><span class="line">    observer.<span class="title function_">observe</span>(el);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> lazyLoadImage;</span><br></pre></td></tr></table></figure><p>注册指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;; import App from &#x27;./App.vue&#x27;; import</span><br><span class="line">lazyLoadImage from &#x27;./directives/lazyLoadImage&#x27;; const app = createApp(App); //</span><br><span class="line">全局注册 v-lazy 指令 app.directive(&#x27;lazy&#x27;, lazyLoadImage); app.mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure><h6 id="4-10-http-请求在-created、mounted-阶段的区别"><a href="#4-10-http-请求在-created、mounted-阶段的区别" class="headerlink" title="4.10 http 请求在 created、mounted 阶段的区别"></a>4.10 http 请求在 created、mounted 阶段的区别</h6><p><strong>选择 <code>created</code> 的场景</strong>：</p><ul><li>需要尽早获取数据以减少页面加载时间和闪烁。</li><li>请求不依赖于 DOM 状态或组件的视觉特征。</li><li>需要在组件挂载之前完成数据处理逻辑。</li></ul><p><strong>选择 <code>mounted</code> 的场景</strong>：</p><ul><li>需要访问或操作 DOM 元素。</li><li>请求或逻辑依赖于组件的视觉特征或布局。</li><li>数据获取可以稍微延迟而不会影响用户体验。</li></ul><h3 id="5-打包工具"><a href="#5-打包工具" class="headerlink" title="5. 打包工具"></a>5. 打包工具</h3><h6 id="5-1-webpack"><a href="#5-1-webpack" class="headerlink" title="5.1 webpack"></a>5.1 webpack</h6><p>执行流程：</p><p>entry：指定模块的入口，加载源文件</p><p>output：输出最终代码</p><p>module：配置各种模块的处理规则</p><p>plugin：配置扩展插件</p><p>devServer：实现本地服务</p><h3 id="6-Html"><a href="#6-Html" class="headerlink" title="6. Html"></a>6. Html</h3><h6 id="6-1-png、jpg、gif"><a href="#6-1-png、jpg、gif" class="headerlink" title="6.1 png、jpg、gif"></a>6.1 png、jpg、gif</h6><p>png：无损压缩，尺寸体积比 jpg 大，适合做小图标</p><p>jpg：采用压缩算法，一点失真，体积较小，适合做大图</p><p>gif：动图</p><h6 id="6-2-DOCTYPE"><a href="#6-2-DOCTYPE" class="headerlink" title="6.2 !DOCTYPE"></a>6.2 !DOCTYPE</h6><ul><li><code>&lt;!DOCTYPE&gt;</code> 是 HTML 文档的<strong>文档类型声明</strong>（Document Type Declaration, DTD），用于告诉浏览器使用哪种 HTML 或 XHTML 标准来解析和显示网页内容。它的存在是为了确保网页在不同浏览器中以一致的方式渲染。</li><li>作用<ul><li>可以让浏览器以标准模式来渲染网页，避免进入怪异模式</li><li>告诉浏览器网页使用的是哪种版本的 HTML 或 XHTML。这有助于浏览器正确地解析和显示网页的内容。</li></ul></li></ul><h6 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h6><h3 id="7-CSS"><a href="#7-CSS" class="headerlink" title="7. CSS"></a>7. CSS</h3><h6 id="7-1-盒子模型"><a href="#7-1-盒子模型" class="headerlink" title="7.1 盒子模型"></a>7.1 盒子模型</h6><p>标准盒子：margin、border、padding、content</p><p>IE 盒子：margin、content（border+padding）</p><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240617091113850.png" alt="image-20240617091113850"></p><h6 id="7-2-line-height-和-height-区别"><a href="#7-2-line-height-和-height-区别" class="headerlink" title="7.2 line-height 和 height 区别"></a>7.2 line-height 和 height 区别</h6><p>height：就是元素的高</p><p>line-height：是每一行文字的高度，如果文字换行则整个盒子会增大</p><h6 id="7-3-CSS-选择符有哪些？那些属性可以继承？"><a href="#7-3-CSS-选择符有哪些？那些属性可以继承？" class="headerlink" title="7.3 CSS 选择符有哪些？那些属性可以继承？"></a>7.3 CSS 选择符有哪些？那些属性可以继承？</h6><p>*：通用</p><p>id 选择器：#</p><p>类选择器：.</p><p>标签选择器：div，p，span……</p><p>相邻选择器：+</p><p>后代选择器：space</p><p>子元素选择器：&gt;</p><p>继承属性：font-size、color、line-height、text-align…….</p><p>不可继承：border、padding、margin</p><h6 id="7-4-CSS-样式的优先级"><a href="#7-4-CSS-样式的优先级" class="headerlink" title="7.4 CSS 样式的优先级"></a>7.4 CSS 样式的优先级</h6><p>优先级比较：! important &gt; 内联样式 &gt; id &gt; class &gt; 标签 &gt; 通配</p><h6 id="7-5-画三角形"><a href="#7-5-画三角形" class="headerlink" title="7.5 画三角形"></a>7.5 画三角形</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 用边框画</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  // 留下一条边框，其他边框设置透明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-6-水平垂直居中"><a href="#7-6-水平垂直居中" class="headerlink" title="7.6 水平垂直居中"></a>7.6 水平垂直居中</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 绝对定位</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 弹性布局</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>：<span class="attribute">flex</span>;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    align-item: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-7-清除浮动"><a href="#7-7-清除浮动" class="headerlink" title="7.7 清除浮动"></a>7.7 清除浮动</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浮动是指使得元素脱离文档流，不再在文档中占据位置</span><br><span class="line">// <span class="number">1</span>.隐藏溢出</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">2</span>.伪类</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-8-隐藏元素的方法"><a href="#7-8-隐藏元素的方法" class="headerlink" title="7.8 隐藏元素的方法"></a>7.8 隐藏元素的方法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: none; // 不占据空间</span><br><span class="line">opactity: <span class="number">0</span>; // 占据空间</span><br><span class="line"><span class="attribute">visibility</span>: hidden; // 占据空间</span><br><span class="line"><span class="attribute">position</span>: absolute; // 不占据空间</span><br></pre></td></tr></table></figure><h6 id="7-9-rem"><a href="#7-9-rem" class="headerlink" title="7.9 rem"></a>7.9 rem</h6><p>一个相对单位，相对于 html 根节点的 font-size 的值，默认为 16px</p><h6 id="7-10-重绘和重排"><a href="#7-10-重绘和重排" class="headerlink" title="7.10 重绘和重排"></a>7.10 重绘和重排</h6><p>重排：浏览器会重新计算元素的大小，当改变元素的大小的时候会重排</p><p>重绘：大小不变，改变颜色会发生重绘</p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h3><h6 id="8-1-网页的访问到呈现的过程"><a href="#8-1-网页的访问到呈现的过程" class="headerlink" title="8,1 网页的访问到呈现的过程"></a>8,1 网页的访问到呈现的过程</h6><ol><li>输入网址<ul><li>用户在浏览器地址栏中输入要访问的网址（URL）。</li></ul></li><li>DNS 解析<ul><li>浏览器首先通过 DNS（Domain Name System）解析将输入的域名转换为对应的 IP 地址。</li><li>DNS 解析的过程可能涉及多个层级，包括根域名服务器、顶级域名服务器、权威服务器等，直至最终获得对应的 IP 地址。</li><li>DNS 查询的顺序通常是从本地缓存开始，如果找不到则逐级向上查询，直至找到对应的 IP 地址。</li></ul></li><li>建立 TCP 连接<ul><li>浏览器获得 IP 地址后，通过 TCP（Transmission Control Protocol）协议与目标服务器建立连接。</li><li>TCP 连接建立的过程包括三次握手：客户端发送 SYN 请求，服务器返回 ACK 确认，客户端再发送 ACK 确认，完成连接建立。</li></ul></li><li>发起 HTTP 请求<ul><li>TCP 连接建立后，浏览器通过 HTTP（HyperText Transfer Protocol）协议向服务器发送请求。</li><li>请求中包含了要获取的资源信息，如 HTML 文件、图片、CSS 文件等。</li></ul></li><li>服务器处理请求<ul><li>服务器接收到客户端的 HTTP 请求后，根据请求的内容进行相应的处理。</li><li>这可能包括查询数据库、执行服务器端代码、读取文件等操作。</li></ul></li><li>服务器响应<ul><li>服务器处理完请求后，将结果封装在 HTTP 响应中，并发送回浏览器。</li><li>HTTP 响应包括状态码、响应头和响应体。状态码表示请求的处理结果，响应头包含一些元信息，而响应体则包含实际的数据，如 HTML 内容或图片数据。</li></ul></li><li>浏览器渲染<ul><li>浏览器接收到服务器的响应后，开始解析 HTML 和其他资源，并渲染页面。</li><li>这个过程包括 HTML 文档的解析、CSS 样式的应用、JavaScript 代码的执行等。</li><li><strong>渲染 HTML</strong>：如果响应体是 HTML 文档，浏览器会开始解析并渲染页面，依次构建 DOM 树和 CSSOM 树，然后生成渲染树。</li><li><strong>处理 <code>&lt;link&gt;</code> 和 <code>&lt;script&gt;</code> 标签</strong>：浏览器会根据 HTML 文档中的 <code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code> 等标签继续发起请求，加载样式表、脚本、图片等资源。</li><li><strong>执行 JavaScript</strong>：浏览器执行加载的 JavaScript 脚本，可能会修改 DOM、发送异步请求、设置事件监听器等。</li><li>浏览器将这些内容组合起来，呈现给用户，形成可交互的网页。</li></ul></li><li>关闭 TCP 连接<ul><li>一旦页面加载完成，浏览器和服务器之间的 TCP 连接就会被关闭。</li><li>关闭 TCP 连接的过程包括四次挥手，确保双方都已准备好断开连接。</li></ul></li></ol><h6 id="8-2-http-和-https"><a href="#8-2-http-和-https" class="headerlink" title="8.2 http 和 https"></a>8.2 http 和 https</h6><ol><li>协议安全性<ul><li>HTTP：不加密数据，数据在传输过程中以明文形式进行，这可能导致数据被截获或被篡改。</li><li>HTTPS：是 HTTP 的安全版，使用 SSL/TLS 协议来加密数据传输，确保数据在传输过程中的安全性。</li></ul></li><li>连接方式<ul><li>HTTP：使用明文传输，不提供数据加密。</li><li>HTTPS：通过 SSL/TLS 协议进行加密传输，保护数据在传输过程中的安全，防止数据被窃取或篡改。</li></ul></li><li>证书管理<ul><li>HTTP：不需要证书。</li><li>HTTPS：需要使用 CA（证书颁发机构）颁发的证书来进行加密和解密操作。因此，在使用 HTTPS 时，需要配置证书。</li></ul></li><li>连接状态<ul><li>HTTP：连接是明文的，一旦连接被截断，数据就可能被窃取或篡改。</li><li>HTTPS：连接在数据传输过程中始终保持加密状态，即使连接在传输过程中被截断，也不会影响数据的加密状态。</li></ul></li><li>端口号<ul><li>HTTP：通常使用 80 端口。</li><li>HTTPS：使用 443 端口，这是通过 TCP/IP 协议对网络通信进行管理的一种约定。</li></ul></li><li>资源消耗<ul><li>HTTP：由于不进行加密和解密操作，资源消耗较小。</li><li>HTTPS：由于使用了加密和解密操作，因此在数据传输过程中需要消耗更多的计算资源。</li></ul></li><li>兼容性<ul><li>HTTP：兼容性较好，可以在各种设备和操作系统上使用。</li><li>HTTPS：由于需要使用 CA 证书，因此在某些情况下可能会出现兼容性问题，例如某些操作系统或浏览器可能不支持某些类型的证书或 SSL/TLS 协议。</li></ul></li></ol><h6 id="8-3-cookie-认证机制"><a href="#8-3-cookie-认证机制" class="headerlink" title="8.3 cookie 认证机制"></a>8.3 cookie 认证机制</h6><ul><li><p>cookie 是存储在用户浏览器中的一节不大于 4kb 的字符串，是一个键值对，还有一些有效期、安全性和使用范围等属性</p></li><li><p>每当客户端发起请求的时候，会自动把当前域名下的所有 cookie 自动发送到服务器</p></li><li>用户执行登录请求后，服务器通过响应头发送 cookie 到浏览器，并保存在浏览器中</li><li>用户通过请求头自动将 cookie 发给服务器，然后验明身份</li><li>cookie 不具有安全性，浏览器提供了对 cookie 的读写功能</li></ul><h6 id="8-4-session-认证机制"><a href="#8-4-session-认证机制" class="headerlink" title="8.4 session 认证机制"></a>8.4 session 认证机制</h6><ul><li>cookie 默认不支持跨域访问，所以涉及到前端跨域请求后端接口的时候需要做其他配置</li></ul><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240812123316981.png" alt="image-20240812123316981"></p><h6 id="8-5-JWT-认证机制"><a href="#8-5-JWT-认证机制" class="headerlink" title="8.5 JWT 认证机制"></a>8.5 JWT 认证机制</h6><ul><li>是目前最流行的跨域认证机制</li><li>token 存储到 localstorage 或者 sessionstorage</li></ul><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240812121824144.png" alt="image-20240812121824144"></p><h6 id="8-6-cookie、sessionstorage、localstorage-的区别"><a href="#8-6-cookie、sessionstorage、localstorage-的区别" class="headerlink" title="8.6 cookie、sessionstorage、localstorage 的区别"></a>8.6 cookie、sessionstorage、localstorage 的区别</h6><p>区别：有效期、存储大小、是否参与服务端通信、读写的方式</p><h6 id="8-7-http-请求"><a href="#8-7-http-请求" class="headerlink" title="8.7 http 请求"></a>8.7 http 请求</h6><ul><li><p><strong>GET</strong>：请求指定的资源。通常用于请求数据而不修改服务器资源。</p></li><li><p><strong>POST</strong>：提交数据给服务器。用于创建新资源或进行数据处理操作。</p></li><li><p><strong>PUT</strong>：更新指定资源，通常用于修改资源内容。</p></li><li><p><strong>DELETE</strong>：删除指定资源。</p></li><li><p><strong>HEAD</strong>：与 GET 方法类似，但只请求资源的头部信息，不返回主体内容。</p><ul><li>用于获取资源的源信息</li><li><strong>验证资源是否存在</strong>：在下载或获取资源之前，通过<code>HEAD</code>请求确认资源是否存在，避免下载错误的内容。</li><li><strong>获取资源的元数据</strong>：例如，获取文件的大小、最后修改时间等信息。</li><li><strong>性能优化</strong>：只请求资源的头部信息，减少不必要的数据传输。</li></ul></li><li><p><strong>OPTIONS</strong>：请求服务器支持的通信选项。</p><ul><li>可以用来了解服务器支持的 HTTP 方法、允许的源（用于 CORS）、是否需要认证等信息</li><li><strong>CORS 预检请求</strong>：浏览器在使用跨域资源共享（CORS）时，先发送<code>OPTIONS</code>请求以确定目标服务器允许哪些请求方法和头部</li><li><strong>探测服务器支持的功能</strong>：例如，检查服务器支持的 HTTP 方法（<code>GET</code>、<code>POST</code>、<code>DELETE</code>等）</li></ul></li><li><p><strong>PATCH</strong>：对资源进行部分修改。</p><ul><li>更新部分资源，只需要发送被修改的数据部分，不必重新发送整个资源</li><li><strong>部分更新</strong>：在编辑应用或 API 中，允许用户更新部分信息而不需要提供所有数据。例如，修改用户的部分资料而不影响其他信息。</li><li><strong>微调资源</strong>：对资源进行小的、特定的修改，例如更改某个配置参数</li></ul></li></ul><h6 id="8-8-http-状态码"><a href="#8-8-http-状态码" class="headerlink" title="8.8 http 状态码"></a>8.8 http 状态码</h6><ul><li><p><strong>1xx（信息性状态码）</strong>：请求已被接收，继续处理。</p><ul><li><strong>100 Continue</strong>：请求的初始部分已收到，客户端应继续发送请求的其余部分（在发送较大的 POST 请求时，使用此状态码来告知客户端继续发送请求内容）。</li><li><strong>101 Switching Protocols</strong>：服务器同意根据客户端的请求更改协议（例如，将 HTTP 更改为 WebSocket）。</li><li><strong>102 Processing (WebDAV)</strong>：服务器已接收到请求，但正在处理，仍未完成（用于避免客户端超时）。</li><li><strong>103 Early Hints</strong>：主要用于提示客户端在最终响应头部到达前开始预加载资源（如 CSS 和 JavaScript）。</li></ul></li><li><p><strong>2xx（成功）</strong>：请求成功。</p><ul><li><strong>200 OK</strong>：请求已成功处理，通常用于<code>GET</code>和<code>POST</code>请求。⭐</li><li><strong>201 Created</strong>：请求已成功，并且服务器创建了一个新资源（通常用于<code>POST</code>请求后，返回新资源的 URI）。⭐</li><li><strong>202 Accepted</strong>：请求已接受，但尚未处理完成（请求可能在稍后处理）。</li><li><strong>203 Non-Authoritative Information</strong>：请求成功，但返回的信息可能来自第三方，而非服务器本身。</li><li><strong>204 No Content</strong>：请求成功，但没有内容返回（通常用于<code>PUT</code>请求后）。</li><li><strong>205 Reset Content</strong>：请求成功，客户端应重置当前页面内容（通常用于表单提交后）。</li><li><strong>206 Partial Content</strong>：服务器成功处理了部分<code>GET</code>请求，通常用于断点续传或分块下载。</li><li><strong>207 Multi-Status (WebDAV)</strong>：返回多个状态码，以表示一个复杂操作的不同结果。</li><li><strong>208 Already Reported (WebDAV)</strong>：成员已在之前的<code>207</code>响应中列出，因此不会重复。</li><li><strong>226 IM Used</strong>：服务器已满足对资源的请求，使用了服务器驱动的内容协商。</li></ul></li><li><p><strong>3xx（重定向）</strong>：请求需要进一步操作。</p><ul><li><strong>300 Multiple Choices</strong>：请求资源有多种表示，客户端可选择一种（例如不同格式或语言版本）。</li><li><strong>301 Moved Permanently</strong>：请求的资源已被永久移动到新位置（应更新书签或链接）。</li><li><strong>302 Found</strong>：请求的资源临时移动到新位置（旧版浏览器解释为临时重定向，但行为与<code>303</code>相似）。</li><li><strong>303 See Other</strong>：建议客户端使用<code>GET</code>方法从新位置获取资源（避免 POST 请求的重复提交）。</li><li><strong>304 Not Modified</strong>：客户端缓存的资源未被修改，直接使用本地缓存即可（节省带宽和加载时间）。⭐</li><li><strong>305 Use Proxy</strong>（已弃用）：请求的资源必须通过指定代理访问</li><li><strong>306 Switch Proxy</strong>（保留不使用）：原意为切换代理，但未被广泛使用。</li><li><strong>307 Temporary Redirect</strong>：请求的资源临时移动到新位置，客户端应保持原有的请求方法。</li><li><strong>308 Permanent Redirect</strong>：请求的资源已永久移动到新位置，客户端应保持原有的请求方法。</li></ul></li><li><p><strong>4xx（客户端错误）</strong>：请求包含语法错误或无法完成。</p><ul><li><strong>400 Bad Request</strong>：请求格式错误，服务器无法理解（例如，语法错误）。</li><li><strong>401 Unauthorized</strong>：请求未授权，需要身份验证（通常用于需要登录的页面）。</li><li><strong>402 Payment Required</strong>（保留不使用）：原意为数字支付机制，目前未广泛使用。</li><li><strong>403 Forbidden</strong>：服务器理解请求，但拒绝执行（例如，没有权限访问资源）。⭐</li><li><strong>404 Not Found</strong>：请求的资源不存在（最常见的错误状态码之一）。⭐</li><li><strong>405 Method Not Allowed</strong>：请求方法不被允许（例如，使用<code>PUT</code>请求到只允许<code>GET</code>的资源）。⭐</li><li><strong>406 Not Acceptable</strong>：服务器无法生成客户端可接受的响应（根据<code>Accept</code>头部）。</li><li><strong>407 Proxy Authentication Required</strong>：需要代理身份验证（类似<code>401 Unauthorized</code>，但用于代理服务器）。</li><li><strong>408 Request Timeout</strong>：服务器等待请求超时（客户端未在预定时间内发送完整请求）</li><li><strong>409 Conflict</strong>：请求与资源的当前状态冲突（例如，编辑同一资源的多个请求）。</li><li><strong>410 Gone</strong>：请求的资源已永久删除（不再提供）。</li><li><strong>411 Length Required</strong>：请求缺少<code>Content-Length</code>头部，服务器拒绝处理。</li><li><strong>412 Precondition Failed</strong>：请求头部中的先决条件之一失败（例如，<code>If-Match</code>头部）。</li><li><strong>413 Payload Too Large</strong>：请求体过大，服务器无法处理。</li><li><strong>414 URI Too Long</strong>：请求的 URI 过长，服务器无法处理。</li><li><strong>415 Unsupported Media Type</strong>：请求的媒体类型不受支持（例如，发送不支持的文件格式）。</li><li><strong>416 Range Not Satisfiable</strong>：请求范围无效（例如，请求文件未包含的字节范围）。</li><li><strong>417 Expectation Failed</strong>：服务器无法满足请求头部<code>Expect</code>中的期望。</li><li><strong>418 I’m a teapot</strong>（彩蛋状态码）：源自愚人节笑话，表示服务器拒绝用茶壶冲泡咖啡。</li><li><strong>421 Misdirected Request</strong>：请求被定向到错误的服务器。</li><li><strong>422 Unprocessable Entity (WebDAV)</strong>：请求格式正确，但无法处理（例如，语义错误）。</li><li><strong>423 Locked (WebDAV)</strong>：资源被锁定，无法访问。</li><li><strong>424 Failed Dependency (WebDAV)</strong>：由于之前的请求失败，本请求依赖关系失败。</li><li><strong>425 Too Early</strong>：服务器拒绝处理过早发送的请求（主要用于避免重放攻击）。</li><li><strong>426 Upgrade Required</strong>：客户端应切换到更高级的协议（如 TLS/1.0）。</li><li><strong>428 Precondition Required</strong>：请求应包含先决条件（避免<code>PUT</code>操作导致并发修改冲突）。</li><li><strong>429 Too Many Requests</strong>：客户端发送请求过多，服务器拒绝处理（通常用于限制流量）。</li><li><strong>431 Request Header Fields Too Large</strong>：请求头部字段过大，服务器拒绝处理。</li><li><strong>451 Unavailable For Legal Reasons</strong>：资源因法律原因不可用（例如，版权或审查原因）。</li></ul></li><li><p><strong>5xx（服务器错误）</strong>：服务器处理请求时发生错误。</p><ul><li><strong>500 Internal Server Error</strong>：服务器内部错误，无法完成请求。</li><li><strong>501 Not Implemented</strong>：服务器不支持请求的方法（例如，服务器未实现某个功能）。⭐</li><li><strong>502 Bad Gateway</strong>：服务器作为网关或代理时，从上游服务器接收到无效响应。</li><li><strong>503 Service Unavailable</strong>：服务器暂时过载或维护，无法处理请求。</li><li><strong>504 Gateway Timeout</strong>：服务器作为网关或代理时，未及时收到上游服务器的响应</li><li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求的 HTTP 协议版本。</li><li><strong>506 Variant Also Negotiates</strong>：服务器内部配置错误导致请求无法处理（循环协商错误）。</li><li><strong>507 Insufficient Storage (WebDAV)</strong>：服务器无法存储请求需要的内容（磁盘空间不足）。</li><li><strong>508 Loop Detected (WebDAV)</strong>：服务器检测到请求中的循环。</li><li><strong>510 Not Extended</strong>：服务器需要进一步扩展请求，才能处理（请求头部不足）。</li><li><strong>511 Network Authentication Required</strong>：客户端需要进行身份验证才能访问网络资源。</li></ul></li></ul><h3 id="9-算法题"><a href="#9-算法题" class="headerlink" title="9. 算法题"></a>9. 算法题</h3><h6 id="9-1-求一个数组的最大不重复子串"><a href="#9-1-求一个数组的最大不重复子串" class="headerlink" title="9.1 求一个数组的最大不重复子串"></a>9.1 求一个数组的最大不重复子串</h6><p>用键值对和两个指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = s[end];</span><br><span class="line">    <span class="keyword">if</span> (seen.<span class="title function_">has</span>(char) &amp;&amp; seen.<span class="title function_">get</span>(char) &gt;= start) &#123;</span><br><span class="line">      start = seen.<span class="title function_">get</span>(char) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seen.<span class="title function_">set</span>(char, end);</span><br><span class="line">    maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLength, end - start + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;abcabcbb&quot;</span>)); <span class="comment">// 输出: 3 (&quot;abc&quot;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;bbbbb&quot;</span>)); <span class="comment">// 输出: 1 (&quot;b&quot;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;pwwkew&quot;</span>)); <span class="comment">// 输出: 3 (&quot;wke&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友联</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/bg.css"/>
      <url>/css/bg.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}@font-face {    /* 为载入的字体取名字(随意) */    font-family: 'xixiFont';    /* 字体文件地址(相对或者绝对路径都可以) */    src: url(../font/ChildFunSans.ttf);    /* 定义加粗样式(加粗多少) */    font-weight: normal;    /* 定义字体样式(斜体/非斜体) */    font-style: normal;    /* 定义显示样式 */    font-display: block;}/* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;}/* 导航栏样式修改 */#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {    left: -38px;}/* 黑夜霓虹灯 *//* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {    text-shadow: 0 0 2px var(--theme-color) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {    text-shadow: 0 0 2px var(--theme-color) !important;}/* 闪烁变动颜色连续渐变 */#site-name,#site-title,#site-subtitle,#post-info,.author-info__name,.author-info__description {    transition: text-shadow 1s linear !important;}#site-title {    padding-bottom: 24px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/darkLight.js"/>
      <url>/js/darkLight.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果    // 颜色索引let idx = 0// 切换颜色function changeColor() {    // 仅夜间模式才启用    // 颜色数组    const arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"]    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        // if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px"        // if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px"        // if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px"        // if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px"        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px"            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px"        } catch {                    }                idx++;        if (idx === arr.length) {            idx = 0        }    } else {        // 白天模式恢复默认        // if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px"        // if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px"        // if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px"        // if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px"        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = ""            document.getElementsByClassName("author-info__description")[0].style.textShadow = ""        } catch {                    }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
