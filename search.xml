<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/25/hello-world/"/>
      <url>/2024/09/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 介绍 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试注意事项</title>
      <link href="/2024/07/25/%E9%9D%A2%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2024/07/25/%E9%9D%A2%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>​ 简单介绍自己的情况，自己的技术和项目，其他不用</p><h6 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h6><ul><li>登录身份验证机制</li><li>轮询机制替代 WebSocket</li><li>异步控制请求</li><li>防抖、节流、图片懒加载</li></ul><h3 id="2-提问-hr"><a href="#2-提问-hr" class="headerlink" title="2. 提问 hr"></a>2. 提问 hr</h3><p>​ 实习期间公司是否有针对实习生的培训机制？</p><p>​ 实习期间如果学校有急事是否可以请假申请？</p><p>​ 实习期间是否有绩效考核？</p><p>​ 大概多久可以收到通知？</p><h3 id="3-JavaScript"><a href="#3-JavaScript" class="headerlink" title="3. JavaScript"></a>3. JavaScript</h3><h6 id="3-1-对象（Object）"><a href="#3-1-对象（Object）" class="headerlink" title="3.1 对象（Object）"></a>3.1 对象（Object）</h6><p>对象是 JavaScript 里的一种数据类型，比数组描述更加详细，能够描述具体的事物</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="attr">name</span>:string,</span><br><span class="line">    <span class="attr">num</span>:number.</span><br><span class="line">    <span class="attr">boolean</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">function</span>: <span class="title function_">fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">let</span> object = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="comment">//or 构造函数创建对象(只能用new来执行，命名必须大写 )</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Obj</span>(string, number);</span><br></pre></td></tr></table></figure><h6 id="3-2-作用域"><a href="#3-2-作用域" class="headerlink" title="3.2 作用域"></a>3.2 作用域</h6><p>作用域规定了变量的访问范围</p><p>局部作用域（函数作用域和块作用域）：外部不能访问</p><p>全局作用域：可以在任意作用域被访问</p><p>作用域链：当多个作用域嵌套时串联形成了作用域链，子作用域可以访问父作用域，反之不可以</p><h6 id="3-3-垃圾回收机制（GC）"><a href="#3-3-垃圾回收机制（GC）" class="headerlink" title="3.3 垃圾回收机制（GC）"></a>3.3 垃圾回收机制（GC）</h6><p>js 内存分配生命周期：内存分配–&gt;内存使用–&gt;内存回收（GC）</p><p>垃圾回收：全局变量一般不会回收，局部变量在不用的时候会自动回收</p><p>垃圾回收机制：一般用来回收复杂数据类型</p><p>算法说明：</p><ol><li><p>跟踪记录被引用的次数</p></li><li><p>如果引用了就记录++</p></li><li><p>如果减少了就记录–</p></li><li><p>如果引用为 0 则释放内存</p></li></ol><p>注意：如果对象之间嵌套引用会引发内存泄漏</p><h6 id="3-4-闭包"><a href="#3-4-闭包" class="headerlink" title="3.4 闭包"></a>3.4 闭包</h6><p>一个函数对周围状态的引用捆绑在一起，内部函数访问其外层函数的作用域 （内层函数+外层函数的变量）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">fn</span>(); <span class="comment">// result 现在是 fn1 函数的引用</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出: 1</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出: 2</span></span><br><span class="line"><span class="title function_">result</span>(); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><h6 id="3-5-箭头函数"><a href="#3-5-箭头函数" class="headerlink" title="3.5 箭头函数"></a>3.5 箭头函数</h6><ul><li><strong>没有自己的 this</strong>：箭头函数不会创建自己的 <code>this</code>，它的 <code>this</code> 值取决于它所在的上下文（也就是定义时的 <code>this</code>），而不是调用时的 <code>this</code>。这使得箭头函数特别适合用作回调函数和需要保持上下文 <code>this</code> 的场景。</li><li><strong>没有 <code>arguments</code> 对象</strong>：箭头函数不绑定 <code>arguments</code> 对象，如果需要访问参数，可以使用剩余参数语法 <code>...args</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalFunction = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFunction</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments 对象，包含函数调用时传递的所有参数</span></span><br><span class="line"><span class="title function_">normalFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出 [1, 2, 3]</span></span><br><span class="line"><span class="title function_">arrowFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li><strong>不可作为构造函数使用</strong>：由于箭头函数没有自己的 <code>this</code>，它不能作为构造函数使用，不能使用 <code>new</code> 关键字调用。</li><li>**不能使用 <code>yield</code>**：箭头函数不能用作生成器函数，不能使用 <code>yield</code> 关键字。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">// 只有一个形参的时候可以省略括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 只有一行函数的时候可以省略大括号</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 只有一行返回时可以省略return</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">x</span>) =&gt; x++;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 直接返回对象(需要加小括号)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">name</span>) =&gt; (&#123; <span class="attr">name</span>: name &#125;);</span><br></pre></td></tr></table></figure><h6 id="3-6-解构赋值"><a href="#3-6-解构赋值" class="headerlink" title="3.6 解构赋值"></a>3.6 解构赋值</h6><ol><li>数组解构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组赋值</span></span><br><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [str1, str2, str3] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [str1, str2, str3] = arr;</span><br><span class="line"><span class="comment">// 交换变量的值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>; <span class="comment">// 必须加分号</span></span><br><span class="line">[b, a] = [a, b](</span><br><span class="line">  <span class="comment">// 两种必须加分号的情况</span></span><br><span class="line">  <span class="comment">// 1. 立即执行函数</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">)();</span><br><span class="line"><span class="comment">// 2. 使用数组时</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b];</span><br><span class="line"><span class="comment">// 所以我建议还是全部加分号吧</span></span><br></pre></td></tr></table></figure><ol start="2"><li>对象结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:string,</span><br><span class="line">    <span class="attr">age</span>:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name, age&#125; = &#123;<span class="attr">name</span>:string, <span class="attr">age</span>:number&#125;; <span class="comment">// 变量名必须和属性名一样</span></span><br><span class="line"><span class="title function_">const</span> (&#123;name, age&#125;) = obj;</span><br></pre></td></tr></table></figure><h6 id="3-7-new-实例化"><a href="#3-7-new-实例化" class="headerlink" title="3.7 new 实例化"></a>3.7 new 实例化</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;XXX&quot;</span>; <span class="comment">// =</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置构造函数Objcect, Array, String, Boolean</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(string, number);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(); <span class="comment">// 获取对象中的所有属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(); <span class="comment">// 获取所有的值</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(newobj, obj); <span class="comment">// 将obj拷贝给newobj</span></span><br></pre></td></tr></table></figure><h6 id="3-8-原型和原型链"><a href="#3-8-原型和原型链" class="headerlink" title="3.8 原型和原型链"></a>3.8 原型和原型链</h6><p>原型：</p><ul><li>在 JavaScript 中，每个对象都有一个与之关联的另一个对象，这个对象就是原型。原型对象可以包含这个对象的所有属性和方法，这样通过继承的方式，其他对象就可以使用这些属性和方法。</li><li><strong><code>__proto__</code> 属性</strong>：这是每个对象都有的一个内部属性，用于指向其原型。这个属性在一些 JavaScript 引擎中实现为 <code>[[Prototype]]</code>，但是大多数浏览器都提供了 <code>__proto__</code> 属性来访问这个内部属性。</li><li><strong><code>prototype</code> 属性</strong>：这是构造函数的一个属性，指向一个对象，所有通过该构造函数创建的实例对象都会共享这个原型对象。</li><li><strong>属性查找</strong>：当访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript 引擎会查找该对象的原型，依此类推，直到找到属性或者达到原型链的末尾（即 <code>Object.prototype</code>）为止。</li><li><strong>实现继承</strong>：原型是 JavaScript 实现继承的基础。通过设置一个对象的 <code>__proto__</code> 属性为另一个对象，实现属性和方法的继承</li><li><strong>共享方法和属性</strong>：通过原型，多个对象可以共享同一个方法或属性，避免了在每个实例上都定义相同的方法或属性的情况</li></ul><p>原型链：</p><ul><li>原型链是由多个对象通过其 <code>__proto__</code> 属性相互连接形成的链式结构，用于实现属性和方法的继承。在 JavaScript 中，对象的属性查找过程就是沿着原型链进行的</li><li><strong>链式结构</strong>：每个对象的 <code>__proto__</code> 属性指向其构造函数的 <code>prototype</code> 属性，从而形成一个链式结构，最终指向 <code>Object.prototype</code>。</li><li><strong>属性查找</strong>：当访问一个对象的属性时，如果该对象本身没有这个属性，JavaScript 引擎会沿着原型链向上查找，直到找到属性或达到原型链的末尾。</li></ul><h6 id="3-9-浅拷贝"><a href="#3-9-浅拷贝" class="headerlink" title="3.9 浅拷贝"></a>3.9 浅拷贝</h6><p>为什么拷贝对象的时候，改变赋值对象的值也会影响原来对象的值？</p><p>答：因为 js 中对象是通过引用而不是通过值来进行赋值的，即变量中存储的是对象在内存中的地址</p><ul><li><p>浅拷贝只复制对象的第一层属性，如果属性是一个对象，则复制的是该对象的引用，而不是对象本身</p></li><li><p>浅拷贝仅复制对象的第一层。对嵌套的对象或数组中的元素进行任何修改，都会反映在原始对象上</p></li><li><p>浅拷贝方法：</p><ul><li>Object.assign()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><ul><li>展开运算符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = &#123; ...obj &#125;;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><ul><li>slice()、concat()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;];</span><br><span class="line"><span class="keyword">const</span> copy = arr.<span class="title function_">slice</span>();</span><br><span class="line">copy[<span class="number">2</span>].<span class="property">a</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">2</span>].<span class="property">a</span>); <span class="comment">// 输出: 4</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="3-10-深拷贝"><a href="#3-10-深拷贝" class="headerlink" title="3.10 深拷贝"></a>3.10 深拷贝</h6><ul><li>深拷贝会递归复制对象中的所有属性，创建一个完全独立的对象副本。修改深拷贝后的对象不会影响原始对象，即使嵌套了多个层级的对象或数组</li><li>深拷贝方法：<ul><li>JSON（局限：不能复制函数、<code>Date</code>、<code>RegExp</code> 等特殊对象类型）</li><li>递归</li><li><code>lodash</code> 库的 <code>_.cloneDeep</code> 方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> copy = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            copy[key] = <span class="title function_">deepCopy</span>(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title function_">deepCopy</span>(obj);</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 输出: 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lodash/cloneDeep</span></span><br><span class="line"><span class="keyword">const</span> <span class="number">0</span> = _.<span class="title function_">cloneDeep</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(obj)  <span class="comment">// 将对象转为json</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(obj))  <span class="comment">// 将json转换为对象</span></span><br></pre></td></tr></table></figure><h6 id="3-11-防抖"><a href="#3-11-防抖" class="headerlink" title="3.11 防抖"></a>3.11 防抖</h6><p>单位时间内，频繁触发事件，只执行一次，防抖可以减少卡顿</p><p>防抖是最后一次触发后延时执行</p><p>案例：用户输入完毕才请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lodash库实现防抖</span></span><br><span class="line">_.<span class="title function_">debounce</span>(<span class="keyword">function</span>, time)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手搓</span></span><br><span class="line"><span class="comment">// 1.声明定时器</span></span><br><span class="line"><span class="comment">// 2.出发事件，先判断是否有定时器，如果有先清除以前的</span></span><br><span class="line"><span class="comment">// 3.如果没有，则开启定时器</span></span><br></pre></td></tr></table></figure><h6 id="3-12-节流"><a href="#3-12-节流" class="headerlink" title="3.12 节流"></a>3.12 节流</h6><p>单位时间内，频繁触发事件，只执行一次</p><p>节流是第一次触发后延时结束</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lodash</span></span><br><span class="line">_.<span class="title function_">throttle</span>(<span class="keyword">function</span>, time)</span><br><span class="line"><span class="comment">// 手搓</span></span><br></pre></td></tr></table></figure><h6 id="3-13-继承"><a href="#3-13-继承" class="headerlink" title="3.13 继承"></a>3.13 继承</h6><p>继承是一种允许一个对象（子类或派生类）使用另一个对象（父类或基类）的属性和方法的能力</p><p>原型链继承、构造函数继承、组合继承</p><p>在 ES6 中，<code>class</code>关键字和<code>extends</code>关键字被引入作为继承语法</p><h6 id="3-14-类"><a href="#3-14-类" class="headerlink" title="3.14 类"></a>3.14 类</h6><p>class</p><h6 id="3-15-ES6-和-ES7-的新特性和语法"><a href="#3-15-ES6-和-ES7-的新特性和语法" class="headerlink" title="3.15 ES6 和 ES7 的新特性和语法"></a>3.15 ES6 和 ES7 的新特性和语法</h6><p>ES6</p><ol><li>块级作用域<ul><li>引入了<code>let</code>和<code>const</code>关键字，允许在块级作用域（例如代码块或<code>&#123;&#125;</code>内部）中声明变量和常量。</li><li><code>let</code>声明的变量具有块级作用域，解决了传统<code>var</code>声明的变量提升问题。</li><li><code>const</code>声明的常量是只读的，一旦赋值后不能再次修改。</li></ul></li><li>箭头函数<ul><li>提供了一种更简洁的函数声明方式，使用<code>=&gt;</code>代替传统的<code>function</code>关键字。</li><li>箭头函数没有自己的<code>this</code>、<code>arguments</code>、<code>super</code>或<code>new.target</code>，它们会捕获其所在上下文的这些值。这使得箭头函数在回调函数中特别有用，因为它们不会改变<code>this</code>的指向。</li></ul></li><li>解构赋值<ul><li>允许从数组或对象中提取值并赋值给变量。</li><li>提供了简洁的语法来访问数组元素或对象属性。</li></ul></li><li>默认参数<ul><li>允许在函数定义时为参数提供默认值。</li><li>如果调用函数时未提供某个参数，则使用默认值。</li></ul></li><li>扩展运算符（Spread Operator）<ul><li>使用<code>...</code>语法，可以将数组或对象展开为独立的元素或属性。</li><li>常用于函数调用、数组字面量或对象字面量中。</li></ul></li><li>模板字符串<ul><li>使用反引号（&#96;&#96;&#96;）定义字符串，并支持变量插值和多行字符串。</li><li>提高了代码的可读性和可维护性。</li></ul></li><li>类和模块<ul><li>引入了<code>class</code>关键字作为面向对象编程的语法糖。</li><li>提供了<code>extends</code>和<code>super</code>关键字来实现类的继承。</li><li>引入了模块化的概念，通过<code>import</code>和<code>export</code>关键字可以方便地导入和导出模块。</li></ul></li><li>Promise 对象和 async&#x2F;await<ul><li>Promise 是处理异步操作的一种模式，它代表了一个最终可能完成（也可能被拒绝）的异步操作及其结果值。</li><li><code>async/await</code>是基于 Promise 的异步编程解决方案，使得异步代码看起来像同步代码一样，更加直观易读。</li></ul></li></ol><p>此外，ES6 还引入了迭代器（Iterator）、生成器（Generator）等其他特性，这些特性为处理集合和异步编程提供了更强大的支持。</p><p>ES7</p><ol><li>Array.prototype.includes()方法<ul><li>这是一个新的数组方法，用于检测一个数组是否包含一个特定的值，返回值为布尔类型。</li><li>与<code>indexOf()</code>方法相比，<code>includes()</code>方法对于<code>NaN</code>的处理更加合理，且语法更加简洁。</li></ul></li><li>幂运算符（<ul><li>引入了新的幂运算符<code>**</code>，用于计算一个数的乘方。</li><li>例如，<code>2 ** 3</code>将返回<code>8</code>。</li></ul></li></ol><h6 id="3-16-回调函数"><a href="#3-16-回调函数" class="headerlink" title="3.16 回调函数"></a>3.16 回调函数</h6><ul><li><p>将函数作为参数传递给另一个函数来异步执行，回调函数会在异步操作后被掉用。</p></li><li><p>易于产生回调地狱（Callback Hell），导致代码难以维护和阅读。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123; <span class="attr">message</span>: <span class="string">&quot;Hello, World!&quot;</span> &#125;;</span><br><span class="line">    <span class="title function_">callback</span>(data);</span><br><span class="line">  &#125;, <span class="number">1000</span>); <span class="comment">// 模拟1秒的异步操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">message</span>); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="3-17-promise"><a href="#3-17-promise" class="headerlink" title="3.17 promise"></a>3.17 promise</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> success = <span class="literal">true</span>; <span class="comment">// 模拟成功或失败</span></span><br><span class="line">      <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(&#123; <span class="attr">message</span>: <span class="string">&quot;Hello, World!&quot;</span> &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Failed to fetch data&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">message</span>); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>); <span class="comment">// 输出: Failed to fetch data</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h6 id="3-18-数据类型"><a href="#3-18-数据类型" class="headerlink" title="3.18 数据类型"></a>3.18 数据类型</h6><ul><li>基本数据类型<ul><li>String：表示一系列字符的文本数据</li><li>Number：表示整数或浮点数</li><li>BigInt：用于表示大于 <code>Number.MAX_SAFE_INTEGER</code> 的整数</li><li>Boolean：表示 <code>true</code> 或 <code>false</code></li><li>Undefined：表示一个变量尚未被赋值（声明但未初始化）</li><li>Null：表示一个空值或无值</li><li>Symbol：表示唯一的标识符</li></ul></li><li>复杂数据类型（引用数据类型）<ul><li>Object：表示一组键值对，其中键是字符串或 Symbol，值可以是任意数据类型</li><li>Array：表示一组有序的数据，数组是对象的一种特殊形式</li><li>Function：表示一段可重复执行的代码，函数也是对象</li><li>Date：表示日期和时间</li><li>RegExp：表示正则表达式模式，用于字符串匹配和替换</li></ul></li></ul><h6 id="3-19-let-var-const"><a href="#3-19-let-var-const" class="headerlink" title="3.19 let\var\const"></a>3.19 let\var\const</h6><table><thead><tr><th>特性</th><th><code>var</code></th><th><code>let</code></th><th><code>const</code></th></tr></thead><tbody><tr><td>作用域</td><td>函数作用域</td><td>块作用域</td><td>块作用域</td></tr><tr><td>变量提升</td><td>声明会提升，初始化为 <code>undefined</code></td><td>声明会提升，但在 TDZ 中无法访问</td><td>声明会提升，但在 TDZ 中无法访问</td></tr><tr><td>重复声明</td><td>允许</td><td>不允许</td><td>不允许</td></tr><tr><td>初始化</td><td>可选</td><td>可选</td><td>必须在声明时初始化</td></tr><tr><td>可变性</td><td>允许重新赋值</td><td>允许重新赋值</td><td>不允许重新赋值</td></tr><tr><td>全局对象的属性</td><td>是</td><td>否</td><td>否</td></tr></tbody></table><h3 id="4-vue"><a href="#4-vue" class="headerlink" title="4. vue"></a>4. vue</h3><h6 id="4-1-各个生命周期需要干的事"><a href="#4-1-各个生命周期需要干的事" class="headerlink" title="4.1 各个生命周期需要干的事"></a>4.1 各个生命周期需要干的事</h6><p>beforeCreate：初始化实例，调用事件和函数（可以查看一下环境变量和初始数据，dom 也没有渲染）</p><p>Created：实例完成对选项的处理，函数和数据都被配置完毕（可以获取数据，但是 dom 节点没有渲染）</p><p>beforeMount：render 函数首次调用（可以获取数据，dom 没有渲染）</p><p>Mounted：实例挂在后被调用（dom 渲染完毕）</p><p>beforeUpdate：数据变化时，获取变化前的 dom</p><p>updated：dom 已经更新</p><p>beforeDestroy：销毁之前，实例还在（可以做一些善后的工作，例如清除一些事件）</p><p>Destroy：销毁完成，实例丧失功能</p><h6 id="4-2-keep-alive"><a href="#4-2-keep-alive" class="headerlink" title="4.2 keep-alive"></a>4.2 keep-alive</h6><p>一个 vue 内置组件，主要用于缓存组件实例，避免组件重复的被创建和销毁组件，提高应用的响应速度和性能。</p><p>提供了两个新的生命周期钩子：</p><p>****activated：****当组件被激活（使用）的时候触发，常用于执行一些数据初始化或者异步操作，在 mounted 后面触发；</p><p>***deactivated：***当组件失活（不被使用）的时候触发；</p><h6 id="4-3-ref"><a href="#4-3-ref" class="headerlink" title="4.3 ref"></a>4.3 ref</h6><ol><li>用于声明响应式数据</li><li>用于获取 dom</li></ol><h6 id="4-4-nextTick"><a href="#4-4-nextTick" class="headerlink" title="4.4 nextTick"></a>4.4 nextTick</h6><p>用于获取更新后的 dom，在 dom 更新结束后执行延迟回调（进行异步操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div ref=&quot;msgDiv&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-if=&quot;msg1&quot;&gt;Message got outside $nextTick: &#123;&#123; msg1 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-if=&quot;msg2&quot;&gt;Message got inside $nextTick: &#123;&#123; msg2 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;div v-if=&quot;msg3&quot;&gt;Message got outside $nextTick: &#123;&#123; msg3 &#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;button @click=&quot;changeMsg&quot;&gt;改变 Msg &lt;/button&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;.app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: &#x27;Hello Vue.&#x27;,</span><br><span class="line">    msg1: &#x27;&#x27;,</span><br><span class="line">    msg2: &#x27;&#x27;,</span><br><span class="line">    msg3: &#x27;&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeMsg() &#123;</span><br><span class="line">      this.msg = &quot;Hello world.&quot;</span><br><span class="line">      this.msg1 = this.$refs.msgDiv.innerHTML</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.msg2 = this.$refs.msgDiv.innerHTML</span><br><span class="line">      &#125;)</span><br><span class="line">      this.msg3 = this.$refs.msgDiv.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h6 id="4-5-计算属性"><a href="#4-5-计算属性" class="headerlink" title="4.5 计算属性"></a>4.5 计算属性</h6><ol><li><strong>简化模板逻辑</strong>：在模板中直接使用复杂表达式可能会使模板变得难以阅读和维护。通过使用计算属性，你可以将这些复杂逻辑移出模板，并将它们封装在可重用的计算属性中。</li><li><strong>依赖缓存</strong>：计算属性是基于它们的响应式依赖进行缓存的。这意味着只要依赖没有发生变化，计算属性就不会重新计算，从而提高了性能。这与方法不同，方法每次被调用时都会重新执行。</li><li><strong>可重用性</strong>：计算属性可以在组件的多个地方被重用，而无需重复编写相同的逻辑。</li><li><strong>更易于测试</strong>：由于计算属性是可重用的，并且与模板逻辑分离，因此它们更易于进行单元测试。</li><li><strong>减少性能开销</strong>：由于计算属性是基于依赖进行缓存的，因此当依赖没有发生变化时，它们不会触发不必要的重新渲染或计算，从而减少了性能开销。</li><li><strong>提高可读性</strong>：通过将复杂的逻辑封装在计算属性中，你可以使模板更加简洁和易于阅读</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;原始值：&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;计算后的值（首字母大写）：&#123;&#123; upperCaseMessage &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;hello vue!&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性</span><br><span class="line">    upperCaseMessage() &#123;</span><br><span class="line">      return this.message.toUpperCase();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="4-6-组件通信"><a href="#4-6-组件通信" class="headerlink" title="4.6 组件通信"></a>4.6 组件通信</h6><ol><li>props：父传子</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件，&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">import Child from &quot;./Child.vue&quot;;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">// 数据</span><br><span class="line">const car = ref(&quot;奔驰&quot;);</span><br><span class="line">const toy = ref();</span><br><span class="line">// 方法</span><br><span class="line">function getToy(value: string) &#123;</span><br><span class="line">  toy.value = value;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const toy = ref(&quot;奥特曼&quot;);</span><br><span class="line"></span><br><span class="line">defineProps([&quot;car&quot;, &quot;getToy&quot;]);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>emit、 $event ：子传父</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span><br><span class="line">&lt;Child @send-toy=&quot;toy = $event&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span><br><span class="line">&lt;button @click=&quot;toy = $event&quot;&gt;测试&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">//子组件中，触发事件： this.$emit(&#x27;send-toy&#x27;, 具体数据)</span><br></pre></td></tr></table></figure><ol start="3"><li><p>mitt：实现任意组件通信 npm i mitt</p></li><li><p>v-model：父子相互通信</p></li><li><p>$attrs：祖孙通信</p></li><li><p>ref、parent：父子、子父</p></li><li><p>provide、inject：祖孙通信</p></li><li><p>pinia：任意组件</p></li><li><p>slot：父子通信</p></li></ol><h6 id="4-7-路由"><a href="#4-7-路由" class="headerlink" title="4.7 路由"></a>4.7 路由</h6><p>hash 模式：兼容性好，有#，seo 优化</p><p>history 模式：简洁美观，需要后端服务器配合，有时候需要重定向</p><p>replace 模式：替换当前记录（和浏览器是否支持页面回退有关）</p><p>push：追加历史记录（和浏览器是否支持页面回退有关）</p><p>一些参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// query查询参数</span><br><span class="line">&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;</span><br><span class="line">&lt;router-link to=&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;&gt;</span><br><span class="line">跳转</span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;</span><br><span class="line">&lt;RouterLink</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    //name:&#x27;xiang&#x27;, //用name也可以跳转</span><br><span class="line">    path: &#x27;/news/detail&#x27;,</span><br><span class="line">    query: &#123;</span><br><span class="line">      id: news.id,</span><br><span class="line">      title: news.title,</span><br><span class="line">      content: news.content,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// params普通传参</span><br><span class="line">&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;</span><br><span class="line">&lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;&#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;</span><br><span class="line">&lt;RouterLink</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    name: &#x27;xiang&#x27;, //用name跳转</span><br><span class="line">    params: &#123;</span><br><span class="line">      id: news.id,</span><br><span class="line">      title: news.title,</span><br><span class="line">      content: news.title,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure><h6 id="4-8-响应式原理"><a href="#4-8-响应式原理" class="headerlink" title="4.8 响应式原理"></a>4.8 响应式原理</h6><p>vue2</p><ol><li><strong>MVVM 模式</strong>：Vue 2 的响应式原理基于 MVVM（Model-View-ViewModel）设计模式。在此模式中，ViewModel 是连接视图（View）和数据模型（Model）的桥梁，它负责将数据模型的变化映射到视图上，并在视图上触发事件时更新数据模型。</li><li>**Object.defineProperty()**：Vue 2 使用<code>Object.defineProperty()</code>方法来实现响应式。具体来说，Vue 在初始化过程中会遍历 data 对象的所有属性，并使用<code>Object.defineProperty()</code>将这些属性转换成 getter 和 setter。这样，当数据模型发生变化时（即属性被读取或修改），Vue 就能够通过 getter 和 setter 捕获这些变化，并触发视图的更新。</li></ol><p>vue3</p><ol><li><strong>Proxy 对象</strong>：Vue 3 使用 ES6 中的 Proxy 对象来实现响应式。Proxy 可以拦截对象的操作，包括属性读取、赋值、删除等，这使得 Vue 能够监听到对象的变化并做出相应的响应。</li><li><strong>Reactive API</strong>：Vue 3 提供了一套 Reactive API 来创建响应式的数据对象。通过调用<code>reactive()</code>函数，可以将一个普通的 JavaScript 对象转换成响应式的对象。当对象发生变化时，Vue 能够检测到并更新相应的视图。</li></ol><table><thead><tr><th>特性</th><th>Vue 2</th><th>Vue 3</th></tr></thead><tbody><tr><td>响应式实现</td><td><code>Object.defineProperty</code></td><td><code>Proxy</code></td></tr><tr><td>动态属性检测</td><td>不支持</td><td>支持</td></tr><tr><td>数组操作检测</td><td>部分支持（通过特定方法）</td><td>完全支持</td></tr><tr><td>深层嵌套对象</td><td>递归处理，性能较差</td><td>性能更好，自动处理所有层级</td></tr><tr><td>依赖收集与更新派发</td><td>手动收集，较为复杂</td><td>自动收集，逻辑简单</td></tr><tr><td>新的响应式 API</td><td>不支持</td><td><code>reactive</code>, <code>ref</code>, <code>computed</code>, etc.</td></tr></tbody></table><h6 id="4-9-图片懒加载"><a href="#4-9-图片懒加载" class="headerlink" title="4.9 图片懒加载"></a>4.9 图片懒加载</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DirectiveBinding</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lazyLoadImage = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el: HTMLImageElement, binding: DirectiveBinding</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建 IntersectionObserver 实例</span></span><br><span class="line">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">      entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">          <span class="comment">// 图片进入视口，设置图片的 src 属性</span></span><br><span class="line">          el.<span class="property">src</span> = binding.<span class="property">value</span>;</span><br><span class="line">          observer.<span class="title function_">unobserve</span>(el); <span class="comment">// 停止观察该图片元素</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始观察元素</span></span><br><span class="line">    observer.<span class="title function_">observe</span>(el);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> lazyLoadImage;</span><br></pre></td></tr></table></figure><p>注册指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;; import App from &#x27;./App.vue&#x27;; import</span><br><span class="line">lazyLoadImage from &#x27;./directives/lazyLoadImage&#x27;; const app = createApp(App); //</span><br><span class="line">全局注册 v-lazy 指令 app.directive(&#x27;lazy&#x27;, lazyLoadImage); app.mount(&#x27;#app&#x27;);</span><br></pre></td></tr></table></figure><h6 id="4-10-http-请求在-created、mounted-阶段的区别"><a href="#4-10-http-请求在-created、mounted-阶段的区别" class="headerlink" title="4.10 http 请求在 created、mounted 阶段的区别"></a>4.10 http 请求在 created、mounted 阶段的区别</h6><p><strong>选择 <code>created</code> 的场景</strong>：</p><ul><li>需要尽早获取数据以减少页面加载时间和闪烁。</li><li>请求不依赖于 DOM 状态或组件的视觉特征。</li><li>需要在组件挂载之前完成数据处理逻辑。</li></ul><p><strong>选择 <code>mounted</code> 的场景</strong>：</p><ul><li>需要访问或操作 DOM 元素。</li><li>请求或逻辑依赖于组件的视觉特征或布局。</li><li>数据获取可以稍微延迟而不会影响用户体验。</li></ul><h3 id="5-打包工具"><a href="#5-打包工具" class="headerlink" title="5. 打包工具"></a>5. 打包工具</h3><h6 id="5-1-webpack"><a href="#5-1-webpack" class="headerlink" title="5.1 webpack"></a>5.1 webpack</h6><p>执行流程：</p><p>entry：指定模块的入口，加载源文件</p><p>output：输出最终代码</p><p>module：配置各种模块的处理规则</p><p>plugin：配置扩展插件</p><p>devServer：实现本地服务</p><h3 id="6-Html"><a href="#6-Html" class="headerlink" title="6. Html"></a>6. Html</h3><h6 id="6-1-png、jpg、gif"><a href="#6-1-png、jpg、gif" class="headerlink" title="6.1 png、jpg、gif"></a>6.1 png、jpg、gif</h6><p>png：无损压缩，尺寸体积比 jpg 大，适合做小图标</p><p>jpg：采用压缩算法，一点失真，体积较小，适合做大图</p><p>gif：动图</p><h6 id="6-2-DOCTYPE"><a href="#6-2-DOCTYPE" class="headerlink" title="6.2 !DOCTYPE"></a>6.2 !DOCTYPE</h6><ul><li><code>&lt;!DOCTYPE&gt;</code> 是 HTML 文档的<strong>文档类型声明</strong>（Document Type Declaration, DTD），用于告诉浏览器使用哪种 HTML 或 XHTML 标准来解析和显示网页内容。它的存在是为了确保网页在不同浏览器中以一致的方式渲染。</li><li>作用<ul><li>可以让浏览器以标准模式来渲染网页，避免进入怪异模式</li><li>告诉浏览器网页使用的是哪种版本的 HTML 或 XHTML。这有助于浏览器正确地解析和显示网页的内容。</li></ul></li></ul><h6 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h6><h3 id="7-CSS"><a href="#7-CSS" class="headerlink" title="7. CSS"></a>7. CSS</h3><h6 id="7-1-盒子模型"><a href="#7-1-盒子模型" class="headerlink" title="7.1 盒子模型"></a>7.1 盒子模型</h6><p>标准盒子：margin、border、padding、content</p><p>IE 盒子：margin、content（border+padding）</p><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240617091113850.png" alt="image-20240617091113850"></p><h6 id="7-2-line-height-和-height-区别"><a href="#7-2-line-height-和-height-区别" class="headerlink" title="7.2 line-height 和 height 区别"></a>7.2 line-height 和 height 区别</h6><p>height：就是元素的高</p><p>line-height：是每一行文字的高度，如果文字换行则整个盒子会增大</p><h6 id="7-3-CSS-选择符有哪些？那些属性可以继承？"><a href="#7-3-CSS-选择符有哪些？那些属性可以继承？" class="headerlink" title="7.3 CSS 选择符有哪些？那些属性可以继承？"></a>7.3 CSS 选择符有哪些？那些属性可以继承？</h6><p>*：通用</p><p>id 选择器：#</p><p>类选择器：.</p><p>标签选择器：div，p，span……</p><p>相邻选择器：+</p><p>后代选择器：space</p><p>子元素选择器：&gt;</p><p>继承属性：font-size、color、line-height、text-align…….</p><p>不可继承：border、padding、margin</p><h6 id="7-4-CSS-样式的优先级"><a href="#7-4-CSS-样式的优先级" class="headerlink" title="7.4 CSS 样式的优先级"></a>7.4 CSS 样式的优先级</h6><p>优先级比较：! important &gt; 内联样式 &gt; id &gt; class &gt; 标签 &gt; 通配</p><h6 id="7-5-画三角形"><a href="#7-5-画三角形" class="headerlink" title="7.5 画三角形"></a>7.5 画三角形</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 用边框画</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  // 留下一条边框，其他边框设置透明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-6-水平垂直居中"><a href="#7-6-水平垂直居中" class="headerlink" title="7.6 水平垂直居中"></a>7.6 水平垂直居中</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 绝对定位</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 弹性布局</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>：<span class="attribute">flex</span>;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    align-item: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-7-清除浮动"><a href="#7-7-清除浮动" class="headerlink" title="7.7 清除浮动"></a>7.7 清除浮动</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 浮动是指使得元素脱离文档流，不再在文档中占据位置</span><br><span class="line">// <span class="number">1</span>.隐藏溢出</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">// <span class="number">2</span>.伪类</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-8-隐藏元素的方法"><a href="#7-8-隐藏元素的方法" class="headerlink" title="7.8 隐藏元素的方法"></a>7.8 隐藏元素的方法</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: none; // 不占据空间</span><br><span class="line">opactity: <span class="number">0</span>; // 占据空间</span><br><span class="line"><span class="attribute">visibility</span>: hidden; // 占据空间</span><br><span class="line"><span class="attribute">position</span>: absolute; // 不占据空间</span><br></pre></td></tr></table></figure><h6 id="7-9-rem"><a href="#7-9-rem" class="headerlink" title="7.9 rem"></a>7.9 rem</h6><p>一个相对单位，相对于 html 根节点的 font-size 的值，默认为 16px</p><h6 id="7-10-重绘和重排"><a href="#7-10-重绘和重排" class="headerlink" title="7.10 重绘和重排"></a>7.10 重绘和重排</h6><p>重排：浏览器会重新计算元素的大小，当改变元素的大小的时候会重排</p><p>重绘：大小不变，改变颜色会发生重绘</p><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h3><h6 id="8-1-网页的访问到呈现的过程"><a href="#8-1-网页的访问到呈现的过程" class="headerlink" title="8,1 网页的访问到呈现的过程"></a>8,1 网页的访问到呈现的过程</h6><ol><li>输入网址<ul><li>用户在浏览器地址栏中输入要访问的网址（URL）。</li></ul></li><li>DNS 解析<ul><li>浏览器首先通过 DNS（Domain Name System）解析将输入的域名转换为对应的 IP 地址。</li><li>DNS 解析的过程可能涉及多个层级，包括根域名服务器、顶级域名服务器、权威服务器等，直至最终获得对应的 IP 地址。</li><li>DNS 查询的顺序通常是从本地缓存开始，如果找不到则逐级向上查询，直至找到对应的 IP 地址。</li></ul></li><li>建立 TCP 连接<ul><li>浏览器获得 IP 地址后，通过 TCP（Transmission Control Protocol）协议与目标服务器建立连接。</li><li>TCP 连接建立的过程包括三次握手：客户端发送 SYN 请求，服务器返回 ACK 确认，客户端再发送 ACK 确认，完成连接建立。</li></ul></li><li>发起 HTTP 请求<ul><li>TCP 连接建立后，浏览器通过 HTTP（HyperText Transfer Protocol）协议向服务器发送请求。</li><li>请求中包含了要获取的资源信息，如 HTML 文件、图片、CSS 文件等。</li></ul></li><li>服务器处理请求<ul><li>服务器接收到客户端的 HTTP 请求后，根据请求的内容进行相应的处理。</li><li>这可能包括查询数据库、执行服务器端代码、读取文件等操作。</li></ul></li><li>服务器响应<ul><li>服务器处理完请求后，将结果封装在 HTTP 响应中，并发送回浏览器。</li><li>HTTP 响应包括状态码、响应头和响应体。状态码表示请求的处理结果，响应头包含一些元信息，而响应体则包含实际的数据，如 HTML 内容或图片数据。</li></ul></li><li>浏览器渲染<ul><li>浏览器接收到服务器的响应后，开始解析 HTML 和其他资源，并渲染页面。</li><li>这个过程包括 HTML 文档的解析、CSS 样式的应用、JavaScript 代码的执行等。</li><li><strong>渲染 HTML</strong>：如果响应体是 HTML 文档，浏览器会开始解析并渲染页面，依次构建 DOM 树和 CSSOM 树，然后生成渲染树。</li><li><strong>处理 <code>&lt;link&gt;</code> 和 <code>&lt;script&gt;</code> 标签</strong>：浏览器会根据 HTML 文档中的 <code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code> 等标签继续发起请求，加载样式表、脚本、图片等资源。</li><li><strong>执行 JavaScript</strong>：浏览器执行加载的 JavaScript 脚本，可能会修改 DOM、发送异步请求、设置事件监听器等。</li><li>浏览器将这些内容组合起来，呈现给用户，形成可交互的网页。</li></ul></li><li>关闭 TCP 连接<ul><li>一旦页面加载完成，浏览器和服务器之间的 TCP 连接就会被关闭。</li><li>关闭 TCP 连接的过程包括四次挥手，确保双方都已准备好断开连接。</li></ul></li></ol><h6 id="8-2-http-和-https"><a href="#8-2-http-和-https" class="headerlink" title="8.2 http 和 https"></a>8.2 http 和 https</h6><ol><li>协议安全性<ul><li>HTTP：不加密数据，数据在传输过程中以明文形式进行，这可能导致数据被截获或被篡改。</li><li>HTTPS：是 HTTP 的安全版，使用 SSL&#x2F;TLS 协议来加密数据传输，确保数据在传输过程中的安全性。</li></ul></li><li>连接方式<ul><li>HTTP：使用明文传输，不提供数据加密。</li><li>HTTPS：通过 SSL&#x2F;TLS 协议进行加密传输，保护数据在传输过程中的安全，防止数据被窃取或篡改。</li></ul></li><li>证书管理<ul><li>HTTP：不需要证书。</li><li>HTTPS：需要使用 CA（证书颁发机构）颁发的证书来进行加密和解密操作。因此，在使用 HTTPS 时，需要配置证书。</li></ul></li><li>连接状态<ul><li>HTTP：连接是明文的，一旦连接被截断，数据就可能被窃取或篡改。</li><li>HTTPS：连接在数据传输过程中始终保持加密状态，即使连接在传输过程中被截断，也不会影响数据的加密状态。</li></ul></li><li>端口号<ul><li>HTTP：通常使用 80 端口。</li><li>HTTPS：使用 443 端口，这是通过 TCP&#x2F;IP 协议对网络通信进行管理的一种约定。</li></ul></li><li>资源消耗<ul><li>HTTP：由于不进行加密和解密操作，资源消耗较小。</li><li>HTTPS：由于使用了加密和解密操作，因此在数据传输过程中需要消耗更多的计算资源。</li></ul></li><li>兼容性<ul><li>HTTP：兼容性较好，可以在各种设备和操作系统上使用。</li><li>HTTPS：由于需要使用 CA 证书，因此在某些情况下可能会出现兼容性问题，例如某些操作系统或浏览器可能不支持某些类型的证书或 SSL&#x2F;TLS 协议。</li></ul></li></ol><h6 id="8-3-cookie-认证机制"><a href="#8-3-cookie-认证机制" class="headerlink" title="8.3 cookie 认证机制"></a>8.3 cookie 认证机制</h6><ul><li><p>cookie 是存储在用户浏览器中的一节不大于 4kb 的字符串，是一个键值对，还有一些有效期、安全性和使用范围等属性</p></li><li><p>每当客户端发起请求的时候，会自动把当前域名下的所有 cookie 自动发送到服务器</p></li><li><p>用户执行登录请求后，服务器通过响应头发送 cookie 到浏览器，并保存在浏览器中</p></li><li><p>用户通过请求头自动将 cookie 发给服务器，然后验明身份</p></li><li><p>cookie 不具有安全性，浏览器提供了对 cookie 的读写功能</p></li></ul><h6 id="8-4-session-认证机制"><a href="#8-4-session-认证机制" class="headerlink" title="8.4 session 认证机制"></a>8.4 session 认证机制</h6><ul><li>cookie 默认不支持跨域访问，所以涉及到前端跨域请求后端接口的时候需要做其他配置</li></ul><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240812123316981.png" alt="image-20240812123316981"></p><h6 id="8-5-JWT-认证机制"><a href="#8-5-JWT-认证机制" class="headerlink" title="8.5 JWT 认证机制"></a>8.5 JWT 认证机制</h6><ul><li>是目前最流行的跨域认证机制</li><li>token 存储到 localstorage 或者 sessionstorage</li></ul><p><img src="C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20240812121824144.png" alt="image-20240812121824144"></p><h6 id="8-6-cookie、sessionstorage、localstorage-的区别"><a href="#8-6-cookie、sessionstorage、localstorage-的区别" class="headerlink" title="8.6 cookie、sessionstorage、localstorage 的区别"></a>8.6 cookie、sessionstorage、localstorage 的区别</h6><p>区别：有效期、存储大小、是否参与服务端通信、读写的方式</p><h6 id="8-7-http-请求"><a href="#8-7-http-请求" class="headerlink" title="8.7 http 请求"></a>8.7 http 请求</h6><ul><li><p><strong>GET</strong>：请求指定的资源。通常用于请求数据而不修改服务器资源。</p></li><li><p><strong>POST</strong>：提交数据给服务器。用于创建新资源或进行数据处理操作。</p></li><li><p><strong>PUT</strong>：更新指定资源，通常用于修改资源内容。</p></li><li><p><strong>DELETE</strong>：删除指定资源。</p></li><li><p><strong>HEAD</strong>：与 GET 方法类似，但只请求资源的头部信息，不返回主体内容。</p><ul><li>用于获取资源的源信息</li><li><strong>验证资源是否存在</strong>：在下载或获取资源之前，通过<code>HEAD</code>请求确认资源是否存在，避免下载错误的内容。</li><li><strong>获取资源的元数据</strong>：例如，获取文件的大小、最后修改时间等信息。</li><li><strong>性能优化</strong>：只请求资源的头部信息，减少不必要的数据传输。</li></ul></li><li><p><strong>OPTIONS</strong>：请求服务器支持的通信选项。</p><ul><li>可以用来了解服务器支持的 HTTP 方法、允许的源（用于 CORS）、是否需要认证等信息</li><li><strong>CORS 预检请求</strong>：浏览器在使用跨域资源共享（CORS）时，先发送<code>OPTIONS</code>请求以确定目标服务器允许哪些请求方法和头部</li><li><strong>探测服务器支持的功能</strong>：例如，检查服务器支持的 HTTP 方法（<code>GET</code>、<code>POST</code>、<code>DELETE</code>等）</li></ul></li><li><p><strong>PATCH</strong>：对资源进行部分修改。</p><ul><li>更新部分资源，只需要发送被修改的数据部分，不必重新发送整个资源</li><li><strong>部分更新</strong>：在编辑应用或 API 中，允许用户更新部分信息而不需要提供所有数据。例如，修改用户的部分资料而不影响其他信息。</li><li><strong>微调资源</strong>：对资源进行小的、特定的修改，例如更改某个配置参数</li></ul></li></ul><h6 id="8-8-http-状态码"><a href="#8-8-http-状态码" class="headerlink" title="8.8 http 状态码"></a>8.8 http 状态码</h6><ul><li><p><strong>1xx（信息性状态码）</strong>：请求已被接收，继续处理。</p><ul><li><strong>100 Continue</strong>：请求的初始部分已收到，客户端应继续发送请求的其余部分（在发送较大的 POST 请求时，使用此状态码来告知客户端继续发送请求内容）。</li><li><strong>101 Switching Protocols</strong>：服务器同意根据客户端的请求更改协议（例如，将 HTTP 更改为 WebSocket）。</li><li>**102 Processing (WebDAV)**：服务器已接收到请求，但正在处理，仍未完成（用于避免客户端超时）。</li><li><strong>103 Early Hints</strong>：主要用于提示客户端在最终响应头部到达前开始预加载资源（如 CSS 和 JavaScript）。</li></ul></li><li><p><strong>2xx（成功）</strong>：请求成功。</p><ul><li><strong>200 OK</strong>：请求已成功处理，通常用于<code>GET</code>和<code>POST</code>请求。⭐</li><li><strong>201 Created</strong>：请求已成功，并且服务器创建了一个新资源（通常用于<code>POST</code>请求后，返回新资源的 URI）。⭐</li><li><strong>202 Accepted</strong>：请求已接受，但尚未处理完成（请求可能在稍后处理）。</li><li><strong>203 Non-Authoritative Information</strong>：请求成功，但返回的信息可能来自第三方，而非服务器本身。</li><li><strong>204 No Content</strong>：请求成功，但没有内容返回（通常用于<code>PUT</code>请求后）。</li><li><strong>205 Reset Content</strong>：请求成功，客户端应重置当前页面内容（通常用于表单提交后）。</li><li><strong>206 Partial Content</strong>：服务器成功处理了部分<code>GET</code>请求，通常用于断点续传或分块下载。</li><li>**207 Multi-Status (WebDAV)**：返回多个状态码，以表示一个复杂操作的不同结果。</li><li>**208 Already Reported (WebDAV)**：成员已在之前的<code>207</code>响应中列出，因此不会重复。</li><li><strong>226 IM Used</strong>：服务器已满足对资源的请求，使用了服务器驱动的内容协商。</li></ul></li><li><p><strong>3xx（重定向）</strong>：请求需要进一步操作。</p><ul><li><strong>300 Multiple Choices</strong>：请求资源有多种表示，客户端可选择一种（例如不同格式或语言版本）。</li><li><strong>301 Moved Permanently</strong>：请求的资源已被永久移动到新位置（应更新书签或链接）。</li><li><strong>302 Found</strong>：请求的资源临时移动到新位置（旧版浏览器解释为临时重定向，但行为与<code>303</code>相似）。</li><li><strong>303 See Other</strong>：建议客户端使用<code>GET</code>方法从新位置获取资源（避免 POST 请求的重复提交）。</li><li><strong>304 Not Modified</strong>：客户端缓存的资源未被修改，直接使用本地缓存即可（节省带宽和加载时间）。⭐</li><li><strong>305 Use Proxy</strong>（已弃用）：请求的资源必须通过指定代理访问</li><li><strong>306 Switch Proxy</strong>（保留不使用）：原意为切换代理，但未被广泛使用。</li><li><strong>307 Temporary Redirect</strong>：请求的资源临时移动到新位置，客户端应保持原有的请求方法。</li><li><strong>308 Permanent Redirect</strong>：请求的资源已永久移动到新位置，客户端应保持原有的请求方法。</li></ul></li><li><p><strong>4xx（客户端错误）</strong>：请求包含语法错误或无法完成。</p><ul><li><strong>400 Bad Request</strong>：请求格式错误，服务器无法理解（例如，语法错误）。</li><li><strong>401 Unauthorized</strong>：请求未授权，需要身份验证（通常用于需要登录的页面）。</li><li><strong>402 Payment Required</strong>（保留不使用）：原意为数字支付机制，目前未广泛使用。</li><li><strong>403 Forbidden</strong>：服务器理解请求，但拒绝执行（例如，没有权限访问资源）。⭐</li><li><strong>404 Not Found</strong>：请求的资源不存在（最常见的错误状态码之一）。⭐</li><li><strong>405 Method Not Allowed</strong>：请求方法不被允许（例如，使用<code>PUT</code>请求到只允许<code>GET</code>的资源）。⭐</li><li><strong>406 Not Acceptable</strong>：服务器无法生成客户端可接受的响应（根据<code>Accept</code>头部）。</li><li><strong>407 Proxy Authentication Required</strong>：需要代理身份验证（类似<code>401 Unauthorized</code>，但用于代理服务器）。</li><li><strong>408 Request Timeout</strong>：服务器等待请求超时（客户端未在预定时间内发送完整请求）</li><li><strong>409 Conflict</strong>：请求与资源的当前状态冲突（例如，编辑同一资源的多个请求）。</li><li><strong>410 Gone</strong>：请求的资源已永久删除（不再提供）。</li><li><strong>411 Length Required</strong>：请求缺少<code>Content-Length</code>头部，服务器拒绝处理。</li><li><strong>412 Precondition Failed</strong>：请求头部中的先决条件之一失败（例如，<code>If-Match</code>头部）。</li><li><strong>413 Payload Too Large</strong>：请求体过大，服务器无法处理。</li><li><strong>414 URI Too Long</strong>：请求的 URI 过长，服务器无法处理。</li><li><strong>415 Unsupported Media Type</strong>：请求的媒体类型不受支持（例如，发送不支持的文件格式）。</li><li><strong>416 Range Not Satisfiable</strong>：请求范围无效（例如，请求文件未包含的字节范围）。</li><li><strong>417 Expectation Failed</strong>：服务器无法满足请求头部<code>Expect</code>中的期望。</li><li><strong>418 I’m a teapot</strong>（彩蛋状态码）：源自愚人节笑话，表示服务器拒绝用茶壶冲泡咖啡。</li><li><strong>421 Misdirected Request</strong>：请求被定向到错误的服务器。</li><li>**422 Unprocessable Entity (WebDAV)**：请求格式正确，但无法处理（例如，语义错误）。</li><li>**423 Locked (WebDAV)**：资源被锁定，无法访问。</li><li>**424 Failed Dependency (WebDAV)**：由于之前的请求失败，本请求依赖关系失败。</li><li><strong>425 Too Early</strong>：服务器拒绝处理过早发送的请求（主要用于避免重放攻击）。</li><li><strong>426 Upgrade Required</strong>：客户端应切换到更高级的协议（如 TLS&#x2F;1.0）。</li><li><strong>428 Precondition Required</strong>：请求应包含先决条件（避免<code>PUT</code>操作导致并发修改冲突）。</li><li><strong>429 Too Many Requests</strong>：客户端发送请求过多，服务器拒绝处理（通常用于限制流量）。</li><li><strong>431 Request Header Fields Too Large</strong>：请求头部字段过大，服务器拒绝处理。</li><li><strong>451 Unavailable For Legal Reasons</strong>：资源因法律原因不可用（例如，版权或审查原因）。</li></ul></li><li><p><strong>5xx（服务器错误）</strong>：服务器处理请求时发生错误。</p><ul><li><strong>500 Internal Server Error</strong>：服务器内部错误，无法完成请求。</li><li><strong>501 Not Implemented</strong>：服务器不支持请求的方法（例如，服务器未实现某个功能）。⭐</li><li><strong>502 Bad Gateway</strong>：服务器作为网关或代理时，从上游服务器接收到无效响应。</li><li><strong>503 Service Unavailable</strong>：服务器暂时过载或维护，无法处理请求。</li><li><strong>504 Gateway Timeout</strong>：服务器作为网关或代理时，未及时收到上游服务器的响应</li><li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求的 HTTP 协议版本。</li><li><strong>506 Variant Also Negotiates</strong>：服务器内部配置错误导致请求无法处理（循环协商错误）。</li><li>**507 Insufficient Storage (WebDAV)**：服务器无法存储请求需要的内容（磁盘空间不足）。</li><li>**508 Loop Detected (WebDAV)**：服务器检测到请求中的循环。</li><li><strong>510 Not Extended</strong>：服务器需要进一步扩展请求，才能处理（请求头部不足）。</li><li><strong>511 Network Authentication Required</strong>：客户端需要进行身份验证才能访问网络资源。</li></ul></li></ul><h3 id="9-算法题"><a href="#9-算法题" class="headerlink" title="9. 算法题"></a>9. 算法题</h3><h6 id="9-1-求一个数组的最大不重复子串"><a href="#9-1-求一个数组的最大不重复子串" class="headerlink" title="9.1 求一个数组的最大不重复子串"></a>9.1 求一个数组的最大不重复子串</h6><p>用键值对和两个指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> maxLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++) &#123;</span><br><span class="line">    <span class="keyword">const</span> char = s[end];</span><br><span class="line">    <span class="keyword">if</span> (seen.<span class="title function_">has</span>(char) &amp;&amp; seen.<span class="title function_">get</span>(char) &gt;= start) &#123;</span><br><span class="line">      start = seen.<span class="title function_">get</span>(char) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seen.<span class="title function_">set</span>(char, end);</span><br><span class="line">    maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLength, end - start + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;abcabcbb&quot;</span>)); <span class="comment">// 输出: 3 (&quot;abc&quot;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;bbbbb&quot;</span>)); <span class="comment">// 输出: 1 (&quot;b&quot;)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;pwwkew&quot;</span>)); <span class="comment">// 输出: 3 (&quot;wke&quot;)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友联</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/bg.css"/>
      <url>/css/bg.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;}#page-header {    background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {    background: transparent !important;}#page-header::before {    background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {    background: transparent !important;}[data-theme="dark"] #page-header::before {    background: transparent !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
